{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport logFactory from '../../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\nvar DEFINED = '1';\n\nvar SegmentCacheInLocalStorage = /*#__PURE__*/function () {\n  function SegmentCacheInLocalStorage(keys) {\n    _classCallCheck(this, SegmentCacheInLocalStorage);\n\n    this.keys = keys; // There is not need to flush segments cache like splits cache, since resetSegments receives the up-to-date list of active segments\n  }\n\n  _createClass(SegmentCacheInLocalStorage, [{\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n\n      try {\n        localStorage.setItem(segmentKey, DEFINED);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n\n      try {\n        localStorage.removeItem(segmentKey);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     *\n     * @param {string[]} segmentNames list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var _this = this;\n\n      var isDiff = false;\n      var index; // Scan current values from localStorage\n\n      var storedSegmentNames = Object.keys(localStorage).reduce(function (accum, key) {\n        var segmentName = _this.keys.extractSegmentName(key);\n\n        if (segmentName) accum.push(segmentName);\n        return accum;\n      }, []); // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && storedSegmentNames.length === segmentNames.length) return isDiff; // Quick path\n\n      if (storedSegmentNames.length !== segmentNames.length) {\n        isDiff = true;\n        storedSegmentNames.forEach(function (segmentName) {\n          return _this.removeFromSegment(segmentName);\n        });\n        segmentNames.forEach(function (segmentName) {\n          return _this.addToSegment(segmentName);\n        });\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && storedSegmentNames.indexOf(segmentNames[index]) !== -1; index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          storedSegmentNames.forEach(function (segmentName) {\n            return _this.removeFromSegment(segmentName);\n          });\n          segmentNames.forEach(function (segmentName) {\n            return _this.addToSegment(segmentName);\n          });\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      return localStorage.getItem(this.keys.buildSegmentNameKey(segmentName)) === DEFINED;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n    /**\n     * Removes list of segments from localStorage\n     * @NOTE this method is not being used at the moment\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing MySegments data from localStorage'); // We cannot simply call `localStorage.clear()` since that implies removing user items from the storage\n      // We could optimize next sentence, since it implies iterating over all localStorage items\n\n      this.resetSegments([]);\n    }\n  }]);\n\n  return SegmentCacheInLocalStorage;\n}();\n\nexport default SegmentCacheInLocalStorage;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/storage/SegmentCache/InLocalStorage/index.js"],"names":["_classCallCheck","_createClass","logFactory","log","DEFINED","SegmentCacheInLocalStorage","keys","key","value","addToSegment","segmentName","segmentKey","buildSegmentNameKey","localStorage","setItem","e","error","removeFromSegment","removeItem","resetSegments","segmentNames","_this","isDiff","index","storedSegmentNames","Object","reduce","accum","extractSegmentName","push","length","forEach","indexOf","isInSegment","getItem","setChangeNumber","getChangeNumber","registerSegment","registerSegments","getRegisteredSegments","flush","info"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport logFactory from '../../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\nvar DEFINED = '1';\n\nvar SegmentCacheInLocalStorage = /*#__PURE__*/function () {\n  function SegmentCacheInLocalStorage(keys) {\n    _classCallCheck(this, SegmentCacheInLocalStorage);\n\n    this.keys = keys; // There is not need to flush segments cache like splits cache, since resetSegments receives the up-to-date list of active segments\n  }\n\n  _createClass(SegmentCacheInLocalStorage, [{\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n\n      try {\n        localStorage.setItem(segmentKey, DEFINED);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n\n      try {\n        localStorage.removeItem(segmentKey);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     *\n     * @param {string[]} segmentNames list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var _this = this;\n\n      var isDiff = false;\n      var index; // Scan current values from localStorage\n\n      var storedSegmentNames = Object.keys(localStorage).reduce(function (accum, key) {\n        var segmentName = _this.keys.extractSegmentName(key);\n\n        if (segmentName) accum.push(segmentName);\n        return accum;\n      }, []); // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && storedSegmentNames.length === segmentNames.length) return isDiff; // Quick path\n\n      if (storedSegmentNames.length !== segmentNames.length) {\n        isDiff = true;\n        storedSegmentNames.forEach(function (segmentName) {\n          return _this.removeFromSegment(segmentName);\n        });\n        segmentNames.forEach(function (segmentName) {\n          return _this.addToSegment(segmentName);\n        });\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && storedSegmentNames.indexOf(segmentNames[index]) !== -1; index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          storedSegmentNames.forEach(function (segmentName) {\n            return _this.removeFromSegment(segmentName);\n          });\n          segmentNames.forEach(function (segmentName) {\n            return _this.addToSegment(segmentName);\n          });\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      return localStorage.getItem(this.keys.buildSegmentNameKey(segmentName)) === DEFINED;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n    /**\n     * Removes list of segments from localStorage\n     * @NOTE this method is not being used at the moment\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing MySegments data from localStorage'); // We cannot simply call `localStorage.clear()` since that implies removing user items from the storage\n      // We could optimize next sentence, since it implies iterating over all localStorage items\n\n      this.resetSegments([]);\n    }\n  }]);\n\n  return SegmentCacheInLocalStorage;\n}();\n\nexport default SegmentCacheInLocalStorage;"]},"metadata":{},"sourceType":"module"}