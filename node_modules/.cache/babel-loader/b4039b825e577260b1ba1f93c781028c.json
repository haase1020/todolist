{"ast":null,"code":"import objectAssign from 'object-assign';\nimport promiseWrapper from '../utils/promise/wrapper';\nimport logFactory from '../utils/logger';\nvar log = logFactory('');\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener'; // default onRejected handler, that just logs the error, if ready promise doesn't have one.\n\nfunction defaultOnRejected(err) {\n  log.error(err);\n}\n/**\n * StatusManager factory.\n * Responsable of exposing public status API: ready promise, event emitter and constants (SDK_READY, etc).\n * It also updates client context according to status events and logs related warnings and errors.\n *\n * @param {Object} context client context\n * @param {number} internalReadyCbCount offset value of SDK_READY listeners that are added/removed internally\n * by the SDK. It is required to properly log the warning 'No listeners for SDK Readiness detected'\n */\n\n\nexport default function callbackHandlerContext(context) {\n  var internalReadyCbCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var gate = context.get(context.constants.READINESS).gate;\n  var readyCbCount = 0;\n  var isReady = false;\n  var hasTimedout = false;\n  var SDK_READY = gate.SDK_READY,\n      SDK_READY_FROM_CACHE = gate.SDK_READY_FROM_CACHE,\n      SDK_UPDATE = gate.SDK_UPDATE,\n      SDK_READY_TIMED_OUT = gate.SDK_READY_TIMED_OUT;\n  gate.on(REMOVE_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY) readyCbCount--;\n  });\n  gate.on(NEW_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n      if (isReady) {\n        log.error(\"A listener was added for \".concat(event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT', \" on the SDK, which has already fired and won't be emitted again. The callback won't be executed.\"));\n      } else if (event === SDK_READY) {\n        readyCbCount++;\n      }\n    }\n  });\n  var readyPromise = generateReadyPromise();\n  gate.once(SDK_READY_FROM_CACHE, function () {\n    log.info('Split SDK is ready from cache.');\n    context.put(context.constants.READY_FROM_CACHE, true);\n  });\n\n  function generateReadyPromise() {\n    var promise = promiseWrapper(new Promise(function (resolve, reject) {\n      gate.once(SDK_READY, function () {\n        if (readyCbCount === internalReadyCbCount && !promise.hasOnFulfilled()) log.warn('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.');\n        context.put(context.constants.READY, true);\n        isReady = true;\n        resolve();\n      });\n      gate.once(SDK_READY_TIMED_OUT, function (error) {\n        context.put(context.constants.HAS_TIMEDOUT, true);\n        hasTimedout = true;\n        reject(error);\n      });\n    }), defaultOnRejected);\n    return promise;\n  }\n\n  return objectAssign( // Expose Event Emitter functionality\n  Object.create(gate), {\n    // Expose the event constants without changing the interface\n    Event: {\n      SDK_READY: SDK_READY,\n      SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n      SDK_UPDATE: SDK_UPDATE,\n      SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT\n    },\n    // Expose the ready promise flag\n    ready: function ready() {\n      if (hasTimedout) {\n        if (!isReady) {\n          return promiseWrapper(Promise.reject('Split SDK has emitted SDK_READY_TIMED_OUT event.'), defaultOnRejected);\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return readyPromise;\n    },\n    // Expose context for internal purposes only. Not considered part of the public API, and will be removed eventually.\n    __context: context\n  });\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/readiness/statusManager.js"],"names":["objectAssign","promiseWrapper","logFactory","log","NEW_LISTENER_EVENT","REMOVE_LISTENER_EVENT","defaultOnRejected","err","error","callbackHandlerContext","context","internalReadyCbCount","arguments","length","undefined","gate","get","constants","READINESS","readyCbCount","isReady","hasTimedout","SDK_READY","SDK_READY_FROM_CACHE","SDK_UPDATE","SDK_READY_TIMED_OUT","on","event","concat","readyPromise","generateReadyPromise","once","info","put","READY_FROM_CACHE","promise","Promise","resolve","reject","hasOnFulfilled","warn","READY","HAS_TIMEDOUT","Object","create","Event","ready","__context"],"mappings":"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","sourcesContent":["import objectAssign from 'object-assign';\nimport promiseWrapper from '../utils/promise/wrapper';\nimport logFactory from '../utils/logger';\nvar log = logFactory('');\nvar NEW_LISTENER_EVENT = 'newListener';\nvar REMOVE_LISTENER_EVENT = 'removeListener'; // default onRejected handler, that just logs the error, if ready promise doesn't have one.\n\nfunction defaultOnRejected(err) {\n  log.error(err);\n}\n/**\n * StatusManager factory.\n * Responsable of exposing public status API: ready promise, event emitter and constants (SDK_READY, etc).\n * It also updates client context according to status events and logs related warnings and errors.\n *\n * @param {Object} context client context\n * @param {number} internalReadyCbCount offset value of SDK_READY listeners that are added/removed internally\n * by the SDK. It is required to properly log the warning 'No listeners for SDK Readiness detected'\n */\n\n\nexport default function callbackHandlerContext(context) {\n  var internalReadyCbCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var gate = context.get(context.constants.READINESS).gate;\n  var readyCbCount = 0;\n  var isReady = false;\n  var hasTimedout = false;\n  var SDK_READY = gate.SDK_READY,\n      SDK_READY_FROM_CACHE = gate.SDK_READY_FROM_CACHE,\n      SDK_UPDATE = gate.SDK_UPDATE,\n      SDK_READY_TIMED_OUT = gate.SDK_READY_TIMED_OUT;\n  gate.on(REMOVE_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY) readyCbCount--;\n  });\n  gate.on(NEW_LISTENER_EVENT, function (event) {\n    if (event === SDK_READY || event === SDK_READY_TIMED_OUT) {\n      if (isReady) {\n        log.error(\"A listener was added for \".concat(event === SDK_READY ? 'SDK_READY' : 'SDK_READY_TIMED_OUT', \" on the SDK, which has already fired and won't be emitted again. The callback won't be executed.\"));\n      } else if (event === SDK_READY) {\n        readyCbCount++;\n      }\n    }\n  });\n  var readyPromise = generateReadyPromise();\n  gate.once(SDK_READY_FROM_CACHE, function () {\n    log.info('Split SDK is ready from cache.');\n    context.put(context.constants.READY_FROM_CACHE, true);\n  });\n\n  function generateReadyPromise() {\n    var promise = promiseWrapper(new Promise(function (resolve, reject) {\n      gate.once(SDK_READY, function () {\n        if (readyCbCount === internalReadyCbCount && !promise.hasOnFulfilled()) log.warn('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.');\n        context.put(context.constants.READY, true);\n        isReady = true;\n        resolve();\n      });\n      gate.once(SDK_READY_TIMED_OUT, function (error) {\n        context.put(context.constants.HAS_TIMEDOUT, true);\n        hasTimedout = true;\n        reject(error);\n      });\n    }), defaultOnRejected);\n    return promise;\n  }\n\n  return objectAssign( // Expose Event Emitter functionality\n  Object.create(gate), {\n    // Expose the event constants without changing the interface\n    Event: {\n      SDK_READY: SDK_READY,\n      SDK_READY_FROM_CACHE: SDK_READY_FROM_CACHE,\n      SDK_UPDATE: SDK_UPDATE,\n      SDK_READY_TIMED_OUT: SDK_READY_TIMED_OUT\n    },\n    // Expose the ready promise flag\n    ready: function ready() {\n      if (hasTimedout) {\n        if (!isReady) {\n          return promiseWrapper(Promise.reject('Split SDK has emitted SDK_READY_TIMED_OUT event.'), defaultOnRejected);\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return readyPromise;\n    },\n    // Expose context for internal purposes only. Not considered part of the public API, and will be removed eventually.\n    __context: context\n  });\n}"]},"metadata":{},"sourceType":"module"}