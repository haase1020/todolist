{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport eventsBulkRequest from '../services/events/bulk';\nimport eventsService from '../services/events';\nimport impressionsBulkRequest from '../services/impressions/bulk';\nimport impressionsCountRequest from '../services/impressions/count';\nimport impressionsService from '../services/impressions';\nimport { fromImpressionsCollector, fromImpressionsCountCollector } from '../services/impressions/dto';\nimport logFactory from '../utils/logger';\nimport { OPTIMIZED, DEBUG } from '../utils/constants';\nimport objectAssign from 'object-assign';\nvar log = logFactory('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\n\nvar UNLOAD_DOM_EVENT = 'unload';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n *\n */\n\nvar BrowserSignalListener = /*#__PURE__*/function () {\n  function BrowserSignalListener(context) {\n    _classCallCheck(this, BrowserSignalListener);\n\n    this.storage = context.get(context.constants.STORAGE);\n    this.settings = context.get(context.constants.SETTINGS);\n    this.flushData = this.flushData.bind(this);\n\n    if (this.settings.sync.impressionsMode === OPTIMIZED) {\n      this.impressionsCounter = context.get(context.constants.IMPRESSIONS_COUNTER);\n    }\n  }\n  /**\n   * start method.\n   * Called when SplitFactory is initialized.\n   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n   */\n\n\n  _createClass(BrowserSignalListener, [{\n    key: \"start\",\n    value: function start() {\n      if (typeof window !== 'undefined' && window.addEventListener) {\n        log.debug('Registering flush handler when unload page event is triggered.');\n        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * stop method.\n     * Called when client is destroyed.\n     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (typeof window !== 'undefined' && window.removeEventListener) {\n        log.debug('Deregistering flush handler when unload page event is triggered.');\n        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * _flushData method.\n     * Called when unload event is triggered. It flushed remaining impressions and events to the backend,\n     * using beacon API if possible, or falling back to regular post transport.\n     */\n\n  }, {\n    key: \"flushData\",\n    value: function flushData() {\n      this._flushImpressions();\n\n      this._flushEvents();\n\n      if (this.impressionsCounter) {\n        this._flushImpressionsCount();\n      }\n    }\n  }, {\n    key: \"_flushImpressions\",\n    value: function _flushImpressions() {\n      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend\n\n      if (!impressions.isEmpty()) {\n        var url = this.settings.url('/testImpressions/beacon');\n        var impressionsPayload = fromImpressionsCollector(impressions, this.settings);\n        var extraMetadata = {\n          // sim stands for Sync/Split Impressions Mode\n          sim: this.settings.sync.impressionsMode === OPTIMIZED ? OPTIMIZED : DEBUG\n        };\n\n        if (!this._sendBeacon(url, impressionsPayload, extraMetadata)) {\n          impressionsService(impressionsBulkRequest(this.settings, {\n            body: JSON.stringify(impressionsPayload)\n          }));\n        }\n\n        impressions.clear();\n      }\n    }\n  }, {\n    key: \"_flushImpressionsCount\",\n    value: function _flushImpressionsCount() {\n      var impressionsCountPayload = {\n        pf: fromImpressionsCountCollector(this.impressionsCounter)\n      };\n      var imprCounts = impressionsCountPayload.pf.length;\n      if (imprCounts === 0) return;\n      var url = this.settings.url('/testImpressions/count/beacon');\n\n      if (!this._sendBeacon(url, impressionsCountPayload)) {\n        impressionsService(impressionsCountRequest(this.settings, {\n          body: JSON.stringify(impressionsCountPayload)\n        }));\n      }\n    }\n  }, {\n    key: \"_flushEvents\",\n    value: function _flushEvents() {\n      var events = this.storage.events; // if there are events in storage, send them to backend\n\n      if (!events.isEmpty()) {\n        var url = this.settings.url('/events/beacon');\n        var eventsPayload = events.toJSON();\n\n        if (!this._sendBeacon(url, eventsPayload)) {\n          eventsService(eventsBulkRequest(this.settings, {\n            body: JSON.stringify(eventsPayload)\n          }));\n        }\n\n        events.clear();\n      }\n    }\n    /**\n     * _sendBeacon method.\n     * Util method that check if beacon API is available, build the payload and send it.\n     */\n\n  }, {\n    key: \"_sendBeacon\",\n    value: function _sendBeacon(url, data, extraMetadata) {\n      // eslint-disable-next-line compat/compat\n      if (typeof navigator !== 'undefined' && navigator.sendBeacon) {\n        var json = {\n          entries: data,\n          token: this.settings.core.authorizationKey,\n          sdk: this.settings.version\n        }; // Extend with endpoint specific metadata where needed\n\n        if (extraMetadata) objectAssign(json, extraMetadata); // Stringify the payload\n\n        var payload = JSON.stringify(json); // eslint-disable-next-line compat/compat\n\n        return navigator.sendBeacon(url, payload);\n      }\n\n      return false;\n    }\n  }]);\n\n  return BrowserSignalListener;\n}();\n\nexport { BrowserSignalListener as default };","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/listeners/browser.js"],"names":["_classCallCheck","_createClass","eventsBulkRequest","eventsService","impressionsBulkRequest","impressionsCountRequest","impressionsService","fromImpressionsCollector","fromImpressionsCountCollector","logFactory","OPTIMIZED","DEBUG","objectAssign","log","UNLOAD_DOM_EVENT","BrowserSignalListener","context","storage","get","constants","STORAGE","settings","SETTINGS","flushData","bind","sync","impressionsMode","impressionsCounter","IMPRESSIONS_COUNTER","key","value","start","window","addEventListener","debug","stop","removeEventListener","_flushImpressions","_flushEvents","_flushImpressionsCount","impressions","isEmpty","url","impressionsPayload","extraMetadata","sim","_sendBeacon","body","JSON","stringify","clear","impressionsCountPayload","pf","imprCounts","length","events","eventsPayload","toJSON","data","navigator","sendBeacon","json","entries","token","core","authorizationKey","sdk","version","payload","default"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport eventsBulkRequest from '../services/events/bulk';\nimport eventsService from '../services/events';\nimport impressionsBulkRequest from '../services/impressions/bulk';\nimport impressionsCountRequest from '../services/impressions/count';\nimport impressionsService from '../services/impressions';\nimport { fromImpressionsCollector, fromImpressionsCountCollector } from '../services/impressions/dto';\nimport logFactory from '../utils/logger';\nimport { OPTIMIZED, DEBUG } from '../utils/constants';\nimport objectAssign from 'object-assign';\nvar log = logFactory('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.\n\nvar UNLOAD_DOM_EVENT = 'unload';\n/**\n * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.\n *\n */\n\nvar BrowserSignalListener = /*#__PURE__*/function () {\n  function BrowserSignalListener(context) {\n    _classCallCheck(this, BrowserSignalListener);\n\n    this.storage = context.get(context.constants.STORAGE);\n    this.settings = context.get(context.constants.SETTINGS);\n    this.flushData = this.flushData.bind(this);\n\n    if (this.settings.sync.impressionsMode === OPTIMIZED) {\n      this.impressionsCounter = context.get(context.constants.IMPRESSIONS_COUNTER);\n    }\n  }\n  /**\n   * start method.\n   * Called when SplitFactory is initialized.\n   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.\n   */\n\n\n  _createClass(BrowserSignalListener, [{\n    key: \"start\",\n    value: function start() {\n      if (typeof window !== 'undefined' && window.addEventListener) {\n        log.debug('Registering flush handler when unload page event is triggered.');\n        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * stop method.\n     * Called when client is destroyed.\n     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (typeof window !== 'undefined' && window.removeEventListener) {\n        log.debug('Deregistering flush handler when unload page event is triggered.');\n        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);\n      }\n    }\n    /**\n     * _flushData method.\n     * Called when unload event is triggered. It flushed remaining impressions and events to the backend,\n     * using beacon API if possible, or falling back to regular post transport.\n     */\n\n  }, {\n    key: \"flushData\",\n    value: function flushData() {\n      this._flushImpressions();\n\n      this._flushEvents();\n\n      if (this.impressionsCounter) {\n        this._flushImpressionsCount();\n      }\n    }\n  }, {\n    key: \"_flushImpressions\",\n    value: function _flushImpressions() {\n      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend\n\n      if (!impressions.isEmpty()) {\n        var url = this.settings.url('/testImpressions/beacon');\n        var impressionsPayload = fromImpressionsCollector(impressions, this.settings);\n        var extraMetadata = {\n          // sim stands for Sync/Split Impressions Mode\n          sim: this.settings.sync.impressionsMode === OPTIMIZED ? OPTIMIZED : DEBUG\n        };\n\n        if (!this._sendBeacon(url, impressionsPayload, extraMetadata)) {\n          impressionsService(impressionsBulkRequest(this.settings, {\n            body: JSON.stringify(impressionsPayload)\n          }));\n        }\n\n        impressions.clear();\n      }\n    }\n  }, {\n    key: \"_flushImpressionsCount\",\n    value: function _flushImpressionsCount() {\n      var impressionsCountPayload = {\n        pf: fromImpressionsCountCollector(this.impressionsCounter)\n      };\n      var imprCounts = impressionsCountPayload.pf.length;\n      if (imprCounts === 0) return;\n      var url = this.settings.url('/testImpressions/count/beacon');\n\n      if (!this._sendBeacon(url, impressionsCountPayload)) {\n        impressionsService(impressionsCountRequest(this.settings, {\n          body: JSON.stringify(impressionsCountPayload)\n        }));\n      }\n    }\n  }, {\n    key: \"_flushEvents\",\n    value: function _flushEvents() {\n      var events = this.storage.events; // if there are events in storage, send them to backend\n\n      if (!events.isEmpty()) {\n        var url = this.settings.url('/events/beacon');\n        var eventsPayload = events.toJSON();\n\n        if (!this._sendBeacon(url, eventsPayload)) {\n          eventsService(eventsBulkRequest(this.settings, {\n            body: JSON.stringify(eventsPayload)\n          }));\n        }\n\n        events.clear();\n      }\n    }\n    /**\n     * _sendBeacon method.\n     * Util method that check if beacon API is available, build the payload and send it.\n     */\n\n  }, {\n    key: \"_sendBeacon\",\n    value: function _sendBeacon(url, data, extraMetadata) {\n      // eslint-disable-next-line compat/compat\n      if (typeof navigator !== 'undefined' && navigator.sendBeacon) {\n        var json = {\n          entries: data,\n          token: this.settings.core.authorizationKey,\n          sdk: this.settings.version\n        }; // Extend with endpoint specific metadata where needed\n\n        if (extraMetadata) objectAssign(json, extraMetadata); // Stringify the payload\n\n        var payload = JSON.stringify(json); // eslint-disable-next-line compat/compat\n\n        return navigator.sendBeacon(url, payload);\n      }\n\n      return false;\n    }\n  }]);\n\n  return BrowserSignalListener;\n}();\n\nexport { BrowserSignalListener as default };"]},"metadata":{},"sourceType":"module"}