{"ast":null,"code":"import React from 'react';\nimport { SplitComponent } from './SplitClient';\nimport { VERSION, WARN_SF_CONFIG_AND_FACTORY, ERROR_SF_NO_CONFIG_AND_FACTORY } from './constants';\nimport { getSplitFactory, destroySplitFactory } from './utils';\n/**\n * SplitFactory will initialize the Split SDK and its main client, listen for its events in order to update the Split Context,\n * and automatically shutdown and release resources when it is unmounted. SplitFactory must wrap other components and functions\n * from this library, since they access the Split Context and its elements (factory, clients, etc).\n *\n * The underlying SDK factory and client is set on the constructor, and cannot be changed during the component lifecycle,\n * even if the component is updated with a different config or factory prop.\n *\n * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK}\n */\n\nclass SplitFactory extends React.Component {\n  constructor(props) {\n    super(props); // Log warning and error\n\n    const {\n      factory: propFactory,\n      config\n    } = props;\n\n    if (!config && !propFactory) {\n      console.error(ERROR_SF_NO_CONFIG_AND_FACTORY);\n    }\n\n    if (config && propFactory) {\n      console.log(WARN_SF_CONFIG_AND_FACTORY);\n    } // Instantiate factory\n\n\n    let factory = null;\n\n    if (propFactory) {\n      factory = propFactory;\n    } else {\n      if (config) {\n        // Don't try this at home. Used to overwrite the settings version when we create our own factory.\n        config.version = VERSION; // We use an idempotent variant of the Split factory builder (i.e., given the same config, it returns the same already\n        // created instance), since React component constructors is part of render-phase and can be invoked multiple times.\n\n        factory = getSplitFactory(config);\n      }\n    }\n\n    this.isFactoryExternal = propFactory ? true : false; // Instantiate main client.\n\n    const client = factory ? factory.client() : null;\n    this.state = {\n      client,\n      factory\n    };\n  }\n\n  componentWillUnmount() {\n    // only destroy the client if the factory was created internally. Otherwise, the shutdown must be handled by the user\n    if (!this.isFactoryExternal && this.state.factory) {\n      destroySplitFactory(this.state.factory);\n    }\n  }\n\n  render() {\n    const {\n      factory,\n      client\n    } = this.state;\n    return React.createElement(SplitComponent, Object.assign({}, this.props, {\n      factory: factory,\n      client: client\n    }));\n  }\n\n}\n\nSplitFactory.defaultProps = {\n  updateOnSdkUpdate: false,\n  updateOnSdkTimedout: false,\n  updateOnSdkReady: true,\n  updateOnSdkReadyFromCache: true,\n  children: null\n};\nexport default SplitFactory;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/SplitFactory.js"],"names":["React","SplitComponent","VERSION","WARN_SF_CONFIG_AND_FACTORY","ERROR_SF_NO_CONFIG_AND_FACTORY","getSplitFactory","destroySplitFactory","SplitFactory","Component","constructor","props","factory","propFactory","config","console","error","log","version","isFactoryExternal","client","state","componentWillUnmount","render","createElement","Object","assign","defaultProps","updateOnSdkUpdate","updateOnSdkTimedout","updateOnSdkReady","updateOnSdkReadyFromCache","children"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,OAAT,EAAkBC,0BAAlB,EAA8CC,8BAA9C,QAAoF,aAApF;AACA,SAASC,eAAT,EAA0BC,mBAA1B,QAAqD,SAArD;AACA;;;;;;;;;;;AAUA,MAAMC,YAAN,SAA2BP,KAAK,CAACQ,SAAjC,CAA2C;AACvCC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN,EADe,CAEf;;AACA,UAAM;AAAEC,MAAAA,OAAO,EAAEC,WAAX;AAAwBC,MAAAA;AAAxB,QAAmCH,KAAzC;;AACA,QAAI,CAACG,MAAD,IAAW,CAACD,WAAhB,EAA6B;AACzBE,MAAAA,OAAO,CAACC,KAAR,CAAcX,8BAAd;AACH;;AACD,QAAIS,MAAM,IAAID,WAAd,EAA2B;AACvBE,MAAAA,OAAO,CAACE,GAAR,CAAYb,0BAAZ;AACH,KATc,CAUf;;;AACA,QAAIQ,OAAO,GAAG,IAAd;;AACA,QAAIC,WAAJ,EAAiB;AACbD,MAAAA,OAAO,GAAGC,WAAV;AACH,KAFD,MAGK;AACD,UAAIC,MAAJ,EAAY;AACR;AACAA,QAAAA,MAAM,CAACI,OAAP,GAAiBf,OAAjB,CAFQ,CAGR;AACA;;AACAS,QAAAA,OAAO,GAAGN,eAAe,CAACQ,MAAD,CAAzB;AACH;AACJ;;AACD,SAAKK,iBAAL,GAAyBN,WAAW,GAAG,IAAH,GAAU,KAA9C,CAxBe,CAyBf;;AACA,UAAMO,MAAM,GAAGR,OAAO,GAAGA,OAAO,CAACQ,MAAR,EAAH,GAAsB,IAA5C;AACA,SAAKC,KAAL,GAAa;AACTD,MAAAA,MADS;AAETR,MAAAA;AAFS,KAAb;AAIH;;AACDU,EAAAA,oBAAoB,GAAG;AACnB;AACA,QAAI,CAAC,KAAKH,iBAAN,IAA2B,KAAKE,KAAL,CAAWT,OAA1C,EAAmD;AAC/CL,MAAAA,mBAAmB,CAAC,KAAKc,KAAL,CAAWT,OAAZ,CAAnB;AACH;AACJ;;AACDW,EAAAA,MAAM,GAAG;AACL,UAAM;AAAEX,MAAAA,OAAF;AAAWQ,MAAAA;AAAX,QAAsB,KAAKC,KAAjC;AACA,WAAQpB,KAAK,CAACuB,aAAN,CAAoBtB,cAApB,EAAoCuB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKf,KAAvB,EAA8B;AAAEC,MAAAA,OAAO,EAAEA,OAAX;AAAoBQ,MAAAA,MAAM,EAAEA;AAA5B,KAA9B,CAApC,CAAR;AACH;;AA1CsC;;AA4C3CZ,YAAY,CAACmB,YAAb,GAA4B;AACxBC,EAAAA,iBAAiB,EAAE,KADK;AAExBC,EAAAA,mBAAmB,EAAE,KAFG;AAGxBC,EAAAA,gBAAgB,EAAE,IAHM;AAIxBC,EAAAA,yBAAyB,EAAE,IAJH;AAKxBC,EAAAA,QAAQ,EAAE;AALc,CAA5B;AAOA,eAAexB,YAAf","sourcesContent":["import React from 'react';\nimport { SplitComponent } from './SplitClient';\nimport { VERSION, WARN_SF_CONFIG_AND_FACTORY, ERROR_SF_NO_CONFIG_AND_FACTORY } from './constants';\nimport { getSplitFactory, destroySplitFactory } from './utils';\n/**\n * SplitFactory will initialize the Split SDK and its main client, listen for its events in order to update the Split Context,\n * and automatically shutdown and release resources when it is unmounted. SplitFactory must wrap other components and functions\n * from this library, since they access the Split Context and its elements (factory, clients, etc).\n *\n * The underlying SDK factory and client is set on the constructor, and cannot be changed during the component lifecycle,\n * even if the component is updated with a different config or factory prop.\n *\n * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK}\n */\nclass SplitFactory extends React.Component {\n    constructor(props) {\n        super(props);\n        // Log warning and error\n        const { factory: propFactory, config } = props;\n        if (!config && !propFactory) {\n            console.error(ERROR_SF_NO_CONFIG_AND_FACTORY);\n        }\n        if (config && propFactory) {\n            console.log(WARN_SF_CONFIG_AND_FACTORY);\n        }\n        // Instantiate factory\n        let factory = null;\n        if (propFactory) {\n            factory = propFactory;\n        }\n        else {\n            if (config) {\n                // Don't try this at home. Used to overwrite the settings version when we create our own factory.\n                config.version = VERSION;\n                // We use an idempotent variant of the Split factory builder (i.e., given the same config, it returns the same already\n                // created instance), since React component constructors is part of render-phase and can be invoked multiple times.\n                factory = getSplitFactory(config);\n            }\n        }\n        this.isFactoryExternal = propFactory ? true : false;\n        // Instantiate main client.\n        const client = factory ? factory.client() : null;\n        this.state = {\n            client,\n            factory,\n        };\n    }\n    componentWillUnmount() {\n        // only destroy the client if the factory was created internally. Otherwise, the shutdown must be handled by the user\n        if (!this.isFactoryExternal && this.state.factory) {\n            destroySplitFactory(this.state.factory);\n        }\n    }\n    render() {\n        const { factory, client } = this.state;\n        return (React.createElement(SplitComponent, Object.assign({}, this.props, { factory: factory, client: client })));\n    }\n}\nSplitFactory.defaultProps = {\n    updateOnSdkUpdate: false,\n    updateOnSdkTimedout: false,\n    updateOnSdkReady: true,\n    updateOnSdkReadyFromCache: true,\n    children: null,\n};\nexport default SplitFactory;\n"]},"metadata":{},"sourceType":"module"}