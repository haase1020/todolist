{"ast":null,"code":"import ManagerFactory from './manager';\nimport StorageFactory from './storage';\nimport ReadinessGateFacade from './readiness';\nimport SettingsFactory from './utils/settings';\nimport Context from './utils/context';\nimport keyParser from './utils/key/parser';\nimport logFactory, { API } from './utils/logger';\nvar log = logFactory('splitio');\nimport tracker from './utils/timeTracker';\nimport SplitFactoryOnline from './factory/online';\nimport SplitFactoryOffline from './factory/offline';\nimport sdkStatusManager from './readiness/statusManager';\nimport { LOCALHOST_MODE } from './utils/constants';\nimport { validateApiKey, validateKey, validateTrafficType } from './utils/inputValidation';\nimport IntegrationsManagerFactory from './integrations';\nimport ImpressionCounter from './impressions/counter';\n\nvar buildInstanceId = function buildInstanceId(key, trafficType) {\n  return \"\".concat(key.matchingKey ? key.matchingKey : key, \"-\").concat(key.bucketingKey ? key.bucketingKey : key, \"-\").concat(trafficType !== undefined ? trafficType : '');\n};\n\nexport function SplitFactory(config) {\n  // Cache instances created per factory.\n  var clientInstances = {}; // Tracking times. We need to do it here because we need the storage created.\n\n  var readyLatencyTrackers = {\n    splitsReadyTracker: tracker.start(tracker.TaskNames.SPLITS_READY),\n    segmentsReadyTracker: tracker.start(tracker.TaskNames.SEGMENTS_READY),\n    sdkReadyTracker: tracker.start(tracker.TaskNames.SDK_READY)\n  };\n  var context = new Context(); // Put settings config within context\n\n  var settings = SettingsFactory(config);\n  context.put(context.constants.SETTINGS, settings); // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.\n\n  validateApiKey(settings.core.authorizationKey); // Put readiness and statusManager within context\n  // Done before adding storage, to let it access readiness gate synchronously\n\n  var gateFactory = ReadinessGateFacade();\n  var readiness = gateFactory(settings.startup.readyTimeout);\n  context.put(context.constants.READINESS, readiness);\n  var statusManager = sdkStatusManager(context);\n  context.put(context.constants.STATUS_MANAGER, statusManager); // Put storage config within context\n\n  var storage = StorageFactory(context);\n  context.put(context.constants.STORAGE, storage); // Put counter\n\n  var impressionsCounter = new ImpressionCounter(); // Instantiates new counter for Impressions\n\n  context.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // Put integrationsManager within context.\n  // It needs to access the storage, settings and potentially other pieces, so it's registered after them.\n\n  var integrationsManager = IntegrationsManagerFactory(context);\n  context.put(context.constants.INTEGRATIONS_MANAGER, integrationsManager); // Define which type of factory to use\n\n  var splitFactory = settings.mode === LOCALHOST_MODE ? SplitFactoryOffline : SplitFactoryOnline;\n\n  var _splitFactory = splitFactory(context, readyLatencyTrackers),\n      mainClientInstance = _splitFactory.api,\n      mainClientMetricCollectors = _splitFactory.metricCollectors; // It makes no sense to have multiple instances of the manager.\n\n\n  var managerInstance = ManagerFactory(storage.splits, context);\n  var parsedDefaultKey = keyParser(settings.core.key);\n  var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);\n  clientInstances[defaultInstanceId] = mainClientInstance;\n  log.info('New Split SDK instance created.');\n  return {\n    // Split evaluation and event tracking engine\n    client: function client(key, trafficType) {\n      if (key === undefined) {\n        log.debug('Retrieving default SDK client.');\n        return mainClientInstance;\n      }\n\n      if (typeof storage.shared != 'function') {\n        throw 'Shared Client not supported by the storage mechanism. Create isolated instances instead.';\n      } // Validate the key value\n\n\n      var validKey = validateKey(key, 'Shared Client instantiation');\n\n      if (validKey === false) {\n        throw 'Shared Client needs a valid key.';\n      }\n\n      var validTrafficType;\n\n      if (trafficType !== undefined) {\n        validTrafficType = validateTrafficType(trafficType, 'Shared Client instantiation');\n\n        if (validTrafficType === false) {\n          throw 'Shared Client needs a valid traffic type or no traffic type at all.';\n        }\n      }\n\n      var instanceId = buildInstanceId(validKey, validTrafficType);\n\n      if (!clientInstances[instanceId]) {\n        var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);\n        var sharedContext = new Context();\n\n        var _readiness = gateFactory(sharedSettings.startup.readyTimeout);\n\n        sharedContext.put(context.constants.READY_FROM_CACHE, context.get(context.constants.READY_FROM_CACHE, true));\n        sharedContext.put(context.constants.READINESS, _readiness); // for shared clients, the internal offset of added/removed SDK_READY callbacks is -1\n\n        sharedContext.put(context.constants.STATUS_MANAGER, sdkStatusManager(sharedContext, -1));\n        sharedContext.put(context.constants.SETTINGS, sharedSettings);\n        sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings));\n        sharedContext.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // As shared clients reuse all the storage information, we don't need to check here if we\n        // will use offline or online mode. We should stick with the original decision.\n\n        clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api;\n        log.info('New shared client instance created.');\n      } else {\n        log.debug('Retrieving existing SDK client.');\n      }\n\n      return clientInstances[instanceId];\n    },\n    // Manager API to explore available information\n    manager: function manager() {\n      log.info('Manager instance retrieved.');\n      return managerInstance;\n    },\n    // Logger wrapper API\n    Logger: API,\n    // Expose SDK settings\n    settings: settings\n  };\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/index.js"],"names":["ManagerFactory","StorageFactory","ReadinessGateFacade","SettingsFactory","Context","keyParser","logFactory","API","log","tracker","SplitFactoryOnline","SplitFactoryOffline","sdkStatusManager","LOCALHOST_MODE","validateApiKey","validateKey","validateTrafficType","IntegrationsManagerFactory","ImpressionCounter","buildInstanceId","key","trafficType","concat","matchingKey","bucketingKey","undefined","SplitFactory","config","clientInstances","readyLatencyTrackers","splitsReadyTracker","start","TaskNames","SPLITS_READY","segmentsReadyTracker","SEGMENTS_READY","sdkReadyTracker","SDK_READY","context","settings","put","constants","SETTINGS","core","authorizationKey","gateFactory","readiness","startup","readyTimeout","READINESS","statusManager","STATUS_MANAGER","storage","STORAGE","impressionsCounter","IMPRESSIONS_COUNTER","integrationsManager","INTEGRATIONS_MANAGER","splitFactory","mode","_splitFactory","mainClientInstance","api","mainClientMetricCollectors","metricCollectors","managerInstance","splits","parsedDefaultKey","defaultInstanceId","info","client","debug","shared","validKey","validTrafficType","instanceId","sharedSettings","overrideKeyAndTT","sharedContext","_readiness","READY_FROM_CACHE","get","manager","Logger"],"mappings":"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","sourcesContent":["import ManagerFactory from './manager';\nimport StorageFactory from './storage';\nimport ReadinessGateFacade from './readiness';\nimport SettingsFactory from './utils/settings';\nimport Context from './utils/context';\nimport keyParser from './utils/key/parser';\nimport logFactory, { API } from './utils/logger';\nvar log = logFactory('splitio');\nimport tracker from './utils/timeTracker';\nimport SplitFactoryOnline from './factory/online';\nimport SplitFactoryOffline from './factory/offline';\nimport sdkStatusManager from './readiness/statusManager';\nimport { LOCALHOST_MODE } from './utils/constants';\nimport { validateApiKey, validateKey, validateTrafficType } from './utils/inputValidation';\nimport IntegrationsManagerFactory from './integrations';\nimport ImpressionCounter from './impressions/counter';\n\nvar buildInstanceId = function buildInstanceId(key, trafficType) {\n  return \"\".concat(key.matchingKey ? key.matchingKey : key, \"-\").concat(key.bucketingKey ? key.bucketingKey : key, \"-\").concat(trafficType !== undefined ? trafficType : '');\n};\n\nexport function SplitFactory(config) {\n  // Cache instances created per factory.\n  var clientInstances = {}; // Tracking times. We need to do it here because we need the storage created.\n\n  var readyLatencyTrackers = {\n    splitsReadyTracker: tracker.start(tracker.TaskNames.SPLITS_READY),\n    segmentsReadyTracker: tracker.start(tracker.TaskNames.SEGMENTS_READY),\n    sdkReadyTracker: tracker.start(tracker.TaskNames.SDK_READY)\n  };\n  var context = new Context(); // Put settings config within context\n\n  var settings = SettingsFactory(config);\n  context.put(context.constants.SETTINGS, settings); // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.\n\n  validateApiKey(settings.core.authorizationKey); // Put readiness and statusManager within context\n  // Done before adding storage, to let it access readiness gate synchronously\n\n  var gateFactory = ReadinessGateFacade();\n  var readiness = gateFactory(settings.startup.readyTimeout);\n  context.put(context.constants.READINESS, readiness);\n  var statusManager = sdkStatusManager(context);\n  context.put(context.constants.STATUS_MANAGER, statusManager); // Put storage config within context\n\n  var storage = StorageFactory(context);\n  context.put(context.constants.STORAGE, storage); // Put counter\n\n  var impressionsCounter = new ImpressionCounter(); // Instantiates new counter for Impressions\n\n  context.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // Put integrationsManager within context.\n  // It needs to access the storage, settings and potentially other pieces, so it's registered after them.\n\n  var integrationsManager = IntegrationsManagerFactory(context);\n  context.put(context.constants.INTEGRATIONS_MANAGER, integrationsManager); // Define which type of factory to use\n\n  var splitFactory = settings.mode === LOCALHOST_MODE ? SplitFactoryOffline : SplitFactoryOnline;\n\n  var _splitFactory = splitFactory(context, readyLatencyTrackers),\n      mainClientInstance = _splitFactory.api,\n      mainClientMetricCollectors = _splitFactory.metricCollectors; // It makes no sense to have multiple instances of the manager.\n\n\n  var managerInstance = ManagerFactory(storage.splits, context);\n  var parsedDefaultKey = keyParser(settings.core.key);\n  var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);\n  clientInstances[defaultInstanceId] = mainClientInstance;\n  log.info('New Split SDK instance created.');\n  return {\n    // Split evaluation and event tracking engine\n    client: function client(key, trafficType) {\n      if (key === undefined) {\n        log.debug('Retrieving default SDK client.');\n        return mainClientInstance;\n      }\n\n      if (typeof storage.shared != 'function') {\n        throw 'Shared Client not supported by the storage mechanism. Create isolated instances instead.';\n      } // Validate the key value\n\n\n      var validKey = validateKey(key, 'Shared Client instantiation');\n\n      if (validKey === false) {\n        throw 'Shared Client needs a valid key.';\n      }\n\n      var validTrafficType;\n\n      if (trafficType !== undefined) {\n        validTrafficType = validateTrafficType(trafficType, 'Shared Client instantiation');\n\n        if (validTrafficType === false) {\n          throw 'Shared Client needs a valid traffic type or no traffic type at all.';\n        }\n      }\n\n      var instanceId = buildInstanceId(validKey, validTrafficType);\n\n      if (!clientInstances[instanceId]) {\n        var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);\n        var sharedContext = new Context();\n\n        var _readiness = gateFactory(sharedSettings.startup.readyTimeout);\n\n        sharedContext.put(context.constants.READY_FROM_CACHE, context.get(context.constants.READY_FROM_CACHE, true));\n        sharedContext.put(context.constants.READINESS, _readiness); // for shared clients, the internal offset of added/removed SDK_READY callbacks is -1\n\n        sharedContext.put(context.constants.STATUS_MANAGER, sdkStatusManager(sharedContext, -1));\n        sharedContext.put(context.constants.SETTINGS, sharedSettings);\n        sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings));\n        sharedContext.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // As shared clients reuse all the storage information, we don't need to check here if we\n        // will use offline or online mode. We should stick with the original decision.\n\n        clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api;\n        log.info('New shared client instance created.');\n      } else {\n        log.debug('Retrieving existing SDK client.');\n      }\n\n      return clientInstances[instanceId];\n    },\n    // Manager API to explore available information\n    manager: function manager() {\n      log.info('Manager instance retrieved.');\n      return managerInstance;\n    },\n    // Logger wrapper API\n    Logger: API,\n    // Expose SDK settings\n    settings: settings\n  };\n}"]},"metadata":{},"sourceType":"module"}