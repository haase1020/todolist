{"ast":null,"code":"import logFactory from '../utils/logger';\nvar log = logFactory('splitio-client');\nimport { evaluateFeature, evaluateFeatures } from '../engine/evaluator';\nimport ImpressionsTracker from '../trackers/impressions';\nimport EventTracker from '../trackers/event';\nimport tracker from '../utils/timeTracker';\nimport thenable from '../utils/promise/thenable';\nimport { matching, bucketing } from '../utils/key/factory';\n/* asynchronous validations that live on the client. */\n\nimport { validateSplitExistance, validateTrafficTypeExistance } from '../utils/inputValidation';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\n\nfunction ClientFactory(context) {\n  var storage = context.get(context.constants.STORAGE);\n  var metricCollectors = context.get(context.constants.COLLECTORS);\n  var impressionsTracker = ImpressionsTracker(context);\n  var eventTracker = EventTracker(context);\n\n  function getTreatment(key, splitName, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var evaluation = evaluateFeature(key, splitName, attributes, storage);\n\n    var wrapUp = function wrapUp(evaluationResult) {\n      var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return treatment;\n    };\n\n    return thenable(evaluation) ? evaluation.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluation);\n  }\n\n  function getTreatmentWithConfig(key, splitName, attributes) {\n    return getTreatment(key, splitName, attributes, true);\n  }\n\n  function getTreatments(key, splitNames, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n\n    var wrapUp = function wrapUp(evaluationResults) {\n      var results = {};\n      Object.keys(evaluationResults).forEach(function (splitName) {\n        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, \"getTreatments\".concat(withConfig ? 'withConfig' : ''));\n      });\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return results;\n    };\n\n    var evaluations = evaluateFeatures(key, splitNames, attributes, storage);\n    return thenable(evaluations) ? evaluations.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluations);\n  }\n\n  function getTreatmentsWithConfig(key, splitNames, attributes) {\n    return getTreatments(key, splitNames, attributes, true);\n  } // Internal function\n\n\n  function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName) {\n    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);\n    var matchingKey = matching(key);\n    var bucketingKey = bucketing(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n\n    if (!isSdkReady) {\n      evaluation = {\n        treatment: CONTROL,\n        label: SDK_NOT_READY\n      };\n    }\n\n    var _evaluation = evaluation,\n        treatment = _evaluation.treatment,\n        label = _evaluation.label,\n        changeNumber = _evaluation.changeNumber,\n        _evaluation$config = _evaluation.config,\n        config = _evaluation$config === void 0 ? null : _evaluation$config;\n    log.info(\"Split: \".concat(splitName, \". Key: \").concat(matchingKey, \". Evaluation: \").concat(treatment, \". Label: \").concat(label));\n\n    if (validateSplitExistance(context, splitName, label, invokingMethodName)) {\n      log.info('Queueing corresponding impression.');\n      impressionsTracker.queue({\n        feature: splitName,\n        keyName: matchingKey,\n        treatment: treatment,\n        time: Date.now(),\n        bucketingKey: bucketingKey,\n        label: label,\n        changeNumber: changeNumber\n      }, attributes);\n    }\n\n    if (withConfig) {\n      return {\n        treatment: treatment,\n        config: config\n      };\n    }\n\n    return treatment;\n  }\n\n  function track(key, trafficTypeName, eventTypeId) {\n    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;\n    var matchingKey = matching(key);\n    var timestamp = Date.now();\n    var eventData = {\n      eventTypeId: eventTypeId,\n      trafficTypeName: trafficTypeName,\n      value: value,\n      timestamp: timestamp,\n      key: matchingKey,\n      properties: properties\n    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n\n    validateTrafficTypeExistance(trafficTypeName, context, 'track');\n    return eventTracker.track(eventData, size);\n  }\n\n  return {\n    getTreatment: getTreatment,\n    getTreatmentWithConfig: getTreatmentWithConfig,\n    getTreatments: getTreatments,\n    getTreatmentsWithConfig: getTreatmentsWithConfig,\n    track: track\n  };\n}\n\nexport default ClientFactory;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/client/client.js"],"names":["logFactory","log","evaluateFeature","evaluateFeatures","ImpressionsTracker","EventTracker","tracker","thenable","matching","bucketing","validateSplitExistance","validateTrafficTypeExistance","SDK_NOT_READY","CONTROL","ClientFactory","context","storage","get","constants","STORAGE","metricCollectors","COLLECTORS","impressionsTracker","eventTracker","getTreatment","key","splitName","attributes","withConfig","arguments","length","undefined","taskToBeTracked","TaskNames","stopLatencyTracker","start","evaluation","wrapUp","evaluationResult","treatment","processEvaluation","concat","track","then","res","getTreatmentWithConfig","getTreatments","splitNames","evaluationResults","results","Object","keys","forEach","evaluations","getTreatmentsWithConfig","invokingMethodName","isSdkReady","READY","READY_FROM_CACHE","matchingKey","bucketingKey","label","_evaluation","changeNumber","_evaluation$config","config","info","queue","feature","keyName","time","Date","now","trafficTypeName","eventTypeId","value","properties","size","timestamp","eventData"],"mappings":"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","sourcesContent":["import logFactory from '../utils/logger';\nvar log = logFactory('splitio-client');\nimport { evaluateFeature, evaluateFeatures } from '../engine/evaluator';\nimport ImpressionsTracker from '../trackers/impressions';\nimport EventTracker from '../trackers/event';\nimport tracker from '../utils/timeTracker';\nimport thenable from '../utils/promise/thenable';\nimport { matching, bucketing } from '../utils/key/factory';\n/* asynchronous validations that live on the client. */\n\nimport { validateSplitExistance, validateTrafficTypeExistance } from '../utils/inputValidation';\nimport { SDK_NOT_READY } from '../utils/labels';\nimport { CONTROL } from '../utils/constants';\n\nfunction ClientFactory(context) {\n  var storage = context.get(context.constants.STORAGE);\n  var metricCollectors = context.get(context.constants.COLLECTORS);\n  var impressionsTracker = ImpressionsTracker(context);\n  var eventTracker = EventTracker(context);\n\n  function getTreatment(key, splitName, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n    var evaluation = evaluateFeature(key, splitName, attributes, storage);\n\n    var wrapUp = function wrapUp(evaluationResult) {\n      var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, \"getTreatment\".concat(withConfig ? 'withConfig' : ''));\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return treatment;\n    };\n\n    return thenable(evaluation) ? evaluation.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluation);\n  }\n\n  function getTreatmentWithConfig(key, splitName, attributes) {\n    return getTreatment(key, splitName, attributes, true);\n  }\n\n  function getTreatments(key, splitNames, attributes) {\n    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];\n    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);\n\n    var wrapUp = function wrapUp(evaluationResults) {\n      var results = {};\n      Object.keys(evaluationResults).forEach(function (splitName) {\n        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, \"getTreatments\".concat(withConfig ? 'withConfig' : ''));\n      });\n      impressionsTracker.track();\n      stopLatencyTracker();\n      return results;\n    };\n\n    var evaluations = evaluateFeatures(key, splitNames, attributes, storage);\n    return thenable(evaluations) ? evaluations.then(function (res) {\n      return wrapUp(res);\n    }) : wrapUp(evaluations);\n  }\n\n  function getTreatmentsWithConfig(key, splitNames, attributes) {\n    return getTreatments(key, splitNames, attributes, true);\n  } // Internal function\n\n\n  function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName) {\n    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);\n    var matchingKey = matching(key);\n    var bucketingKey = bucketing(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.\n\n    if (!isSdkReady) {\n      evaluation = {\n        treatment: CONTROL,\n        label: SDK_NOT_READY\n      };\n    }\n\n    var _evaluation = evaluation,\n        treatment = _evaluation.treatment,\n        label = _evaluation.label,\n        changeNumber = _evaluation.changeNumber,\n        _evaluation$config = _evaluation.config,\n        config = _evaluation$config === void 0 ? null : _evaluation$config;\n    log.info(\"Split: \".concat(splitName, \". Key: \").concat(matchingKey, \". Evaluation: \").concat(treatment, \". Label: \").concat(label));\n\n    if (validateSplitExistance(context, splitName, label, invokingMethodName)) {\n      log.info('Queueing corresponding impression.');\n      impressionsTracker.queue({\n        feature: splitName,\n        keyName: matchingKey,\n        treatment: treatment,\n        time: Date.now(),\n        bucketingKey: bucketingKey,\n        label: label,\n        changeNumber: changeNumber\n      }, attributes);\n    }\n\n    if (withConfig) {\n      return {\n        treatment: treatment,\n        config: config\n      };\n    }\n\n    return treatment;\n  }\n\n  function track(key, trafficTypeName, eventTypeId) {\n    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;\n    var matchingKey = matching(key);\n    var timestamp = Date.now();\n    var eventData = {\n      eventTypeId: eventTypeId,\n      trafficTypeName: trafficTypeName,\n      value: value,\n      timestamp: timestamp,\n      key: matchingKey,\n      properties: properties\n    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.\n\n    validateTrafficTypeExistance(trafficTypeName, context, 'track');\n    return eventTracker.track(eventData, size);\n  }\n\n  return {\n    getTreatment: getTreatment,\n    getTreatmentWithConfig: getTreatmentWithConfig,\n    getTreatments: getTreatments,\n    getTreatmentsWithConfig: getTreatmentsWithConfig,\n    track: track\n  };\n}\n\nexport default ClientFactory;"]},"metadata":{},"sourceType":"module"}