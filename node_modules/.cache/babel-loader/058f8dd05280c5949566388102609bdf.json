{"ast":null,"code":"import PushManagerFactory from './PushManager';\nimport FullProducerFactory from '../producer';\nimport PartialProducerFactory from '../producer/browser/Partial';\nimport { matching } from '../utils/key/factory';\nimport { forOwn, toString } from '../utils/lang';\nimport logFactory from '../utils/logger';\nimport { PUSH_DISCONNECT, PUSH_CONNECT } from './constants';\nvar log = logFactory('splitio-sync:sync-manager');\n/**\n * Factory of sync manager for browser\n *\n * @param context main client context\n */\n\nexport default function BrowserSyncManagerFactory(mainContext) {\n  // map of user keys to client contexts\n  var contexts = {};\n  var settings = mainContext.get(mainContext.constants.SETTINGS); // call `createInstance` before creating PushManager, since it is in charge of creating the full producer and adding it into the main context.\n\n  var syncManager = createInstance(false, mainContext);\n  var pushManager = settings.streamingEnabled ? PushManagerFactory(mainContext, contexts) : undefined;\n  var mainProducer = mainContext.get(mainContext.constants.PRODUCER);\n\n  function startPolling() {\n    if (!mainProducer.isRunning()) {\n      log.info('Streaming not available. Starting periodic fetch of data.');\n      forOwn(contexts, function (context) {\n        var producer = context.get(context.constants.PRODUCER);\n        producer.start();\n      });\n    } else {\n      log.info('Streaming couldn\\'t connect. Continue periodic fetch of data.');\n    }\n  }\n\n  function stopPollingAndSyncAll() {\n    if (mainProducer.isRunning()) {\n      log.info('PUSH (re)connected. Syncing and stopping periodic fetch of data.'); // if polling, stop\n\n      forOwn(contexts, function (context) {\n        var producer = context.get(context.constants.PRODUCER);\n        producer.stop();\n      });\n    }\n\n    syncAll();\n  }\n\n  function syncAll() {\n    // fetch splits and segments\n    var mainProducer = mainContext.get(mainContext.constants.PRODUCER);\n    mainProducer.synchronizeSplits();\n    forOwn(contexts, function (context) {\n      var producer = context.get(context.constants.PRODUCER);\n      producer.synchronizeMySegments();\n    });\n  }\n  /**\n   * Creates a SyncManager that handles the synchronization of clients (main and shared ones).\n   * Internally, it creates the client producer, adds it into its context, and defines the `start` and `stop` methods that handle synchronization.\n   *\n   * @param {Object} context\n   * @param {boolean} isSharedClient\n   */\n\n\n  function createInstance(isSharedClient, context) {\n    var producer = isSharedClient ? PartialProducerFactory(context) : FullProducerFactory(context);\n    var settings = context.get(context.constants.SETTINGS); // we need to stringify the user key (or matching key) in case it is not an string, to hash and pass as query param for authentication\n\n    var userKey = toString(matching(settings.core.key));\n    context.put(context.constants.PRODUCER, producer);\n    if (contexts[userKey]) log.warn('A client with the same user key has already been created. Only the new instance will be properly synchronized.');\n    contexts[userKey] = context;\n    return {\n      start: function start() {\n        // start syncing\n        if (pushManager) {\n          if (!isSharedClient) {\n            syncAll(); // initial syncAll (only when main client is created)\n\n            pushManager.on(PUSH_CONNECT, stopPollingAndSyncAll);\n            pushManager.on(PUSH_DISCONNECT, startPolling);\n          } else {\n            if (mainProducer.isRunning()) {\n              // if doing polling, we must start the producer periodic fetch of data\n              producer.start();\n            } else {\n              // if not doing polling, we must perform a `producer.synchronizeMySegments` for the initial fetch\n              // of segments since `syncAll` was already executed when starting the main client\n              producer.synchronizeMySegments();\n            }\n          }\n\n          pushManager.startNewClient(userKey, context);\n        } else {\n          producer.start();\n        }\n      },\n      stop: function stop() {\n        var context = contexts[userKey];\n\n        if (context) {\n          // check in case `client.destroy()` has been invoked more than once for the same client\n          delete contexts[userKey];\n\n          if (pushManager) {\n            pushManager.removeClient(userKey); // stop push if stoping main client\n\n            if (!isSharedClient) pushManager.stop(); // We don't reconnect pushmanager when removing a shared client,\n            // since it is more costly than continue listening the channel\n          }\n\n          if (producer.isRunning()) producer.stop();\n        }\n      }\n    };\n  } // For the main client we return a SyncManager with 3 methods: start, stop and shared. The last is used to instantiate \"partial SyncManagers\".\n\n\n  syncManager.shared = createInstance.bind(null, true);\n  return syncManager;\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/browser.js"],"names":["PushManagerFactory","FullProducerFactory","PartialProducerFactory","matching","forOwn","toString","logFactory","PUSH_DISCONNECT","PUSH_CONNECT","log","BrowserSyncManagerFactory","mainContext","contexts","settings","get","constants","SETTINGS","syncManager","createInstance","pushManager","streamingEnabled","undefined","mainProducer","PRODUCER","startPolling","isRunning","info","context","producer","start","stopPollingAndSyncAll","stop","syncAll","synchronizeSplits","synchronizeMySegments","isSharedClient","userKey","core","key","put","warn","on","startNewClient","removeClient","shared","bind"],"mappings":"AAAA,OAAOA,kBAAP,MAA+B,eAA/B;AACA,OAAOC,mBAAP,MAAgC,aAAhC;AACA,OAAOC,sBAAP,MAAmC,6BAAnC;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,MAAT,EAAiBC,QAAjB,QAAiC,eAAjC;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,SAASC,eAAT,EAA0BC,YAA1B,QAA8C,aAA9C;AACA,IAAIC,GAAG,GAAGH,UAAU,CAAC,2BAAD,CAApB;AACA;;;;;;AAMA,eAAe,SAASI,yBAAT,CAAmCC,WAAnC,EAAgD;AAC7D;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,QAAQ,GAAGF,WAAW,CAACG,GAAZ,CAAgBH,WAAW,CAACI,SAAZ,CAAsBC,QAAtC,CAAf,CAH6D,CAGG;;AAEhE,MAAIC,WAAW,GAAGC,cAAc,CAAC,KAAD,EAAQP,WAAR,CAAhC;AACA,MAAIQ,WAAW,GAAGN,QAAQ,CAACO,gBAAT,GAA4BpB,kBAAkB,CAACW,WAAD,EAAcC,QAAd,CAA9C,GAAwES,SAA1F;AACA,MAAIC,YAAY,GAAGX,WAAW,CAACG,GAAZ,CAAgBH,WAAW,CAACI,SAAZ,CAAsBQ,QAAtC,CAAnB;;AAEA,WAASC,YAAT,GAAwB;AACtB,QAAI,CAACF,YAAY,CAACG,SAAb,EAAL,EAA+B;AAC7BhB,MAAAA,GAAG,CAACiB,IAAJ,CAAS,2DAAT;AACAtB,MAAAA,MAAM,CAACQ,QAAD,EAAW,UAAUe,OAAV,EAAmB;AAClC,YAAIC,QAAQ,GAAGD,OAAO,CAACb,GAAR,CAAYa,OAAO,CAACZ,SAAR,CAAkBQ,QAA9B,CAAf;AACAK,QAAAA,QAAQ,CAACC,KAAT;AACD,OAHK,CAAN;AAID,KAND,MAMO;AACLpB,MAAAA,GAAG,CAACiB,IAAJ,CAAS,+DAAT;AACD;AACF;;AAED,WAASI,qBAAT,GAAiC;AAC/B,QAAIR,YAAY,CAACG,SAAb,EAAJ,EAA8B;AAC5BhB,MAAAA,GAAG,CAACiB,IAAJ,CAAS,kEAAT,EAD4B,CACkD;;AAE9EtB,MAAAA,MAAM,CAACQ,QAAD,EAAW,UAAUe,OAAV,EAAmB;AAClC,YAAIC,QAAQ,GAAGD,OAAO,CAACb,GAAR,CAAYa,OAAO,CAACZ,SAAR,CAAkBQ,QAA9B,CAAf;AACAK,QAAAA,QAAQ,CAACG,IAAT;AACD,OAHK,CAAN;AAID;;AAEDC,IAAAA,OAAO;AACR;;AAED,WAASA,OAAT,GAAmB;AACjB;AACA,QAAIV,YAAY,GAAGX,WAAW,CAACG,GAAZ,CAAgBH,WAAW,CAACI,SAAZ,CAAsBQ,QAAtC,CAAnB;AACAD,IAAAA,YAAY,CAACW,iBAAb;AACA7B,IAAAA,MAAM,CAACQ,QAAD,EAAW,UAAUe,OAAV,EAAmB;AAClC,UAAIC,QAAQ,GAAGD,OAAO,CAACb,GAAR,CAAYa,OAAO,CAACZ,SAAR,CAAkBQ,QAA9B,CAAf;AACAK,MAAAA,QAAQ,CAACM,qBAAT;AACD,KAHK,CAAN;AAID;AACD;;;;;;;;;AASA,WAAShB,cAAT,CAAwBiB,cAAxB,EAAwCR,OAAxC,EAAiD;AAC/C,QAAIC,QAAQ,GAAGO,cAAc,GAAGjC,sBAAsB,CAACyB,OAAD,CAAzB,GAAqC1B,mBAAmB,CAAC0B,OAAD,CAArF;AACA,QAAId,QAAQ,GAAGc,OAAO,CAACb,GAAR,CAAYa,OAAO,CAACZ,SAAR,CAAkBC,QAA9B,CAAf,CAF+C,CAES;;AAExD,QAAIoB,OAAO,GAAG/B,QAAQ,CAACF,QAAQ,CAACU,QAAQ,CAACwB,IAAT,CAAcC,GAAf,CAAT,CAAtB;AACAX,IAAAA,OAAO,CAACY,GAAR,CAAYZ,OAAO,CAACZ,SAAR,CAAkBQ,QAA9B,EAAwCK,QAAxC;AACA,QAAIhB,QAAQ,CAACwB,OAAD,CAAZ,EAAuB3B,GAAG,CAAC+B,IAAJ,CAAS,gHAAT;AACvB5B,IAAAA,QAAQ,CAACwB,OAAD,CAAR,GAAoBT,OAApB;AACA,WAAO;AACLE,MAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB;AACA,YAAIV,WAAJ,EAAiB;AACf,cAAI,CAACgB,cAAL,EAAqB;AACnBH,YAAAA,OAAO,GADY,CACR;;AAEXb,YAAAA,WAAW,CAACsB,EAAZ,CAAejC,YAAf,EAA6BsB,qBAA7B;AACAX,YAAAA,WAAW,CAACsB,EAAZ,CAAelC,eAAf,EAAgCiB,YAAhC;AACD,WALD,MAKO;AACL,gBAAIF,YAAY,CAACG,SAAb,EAAJ,EAA8B;AAC5B;AACAG,cAAAA,QAAQ,CAACC,KAAT;AACD,aAHD,MAGO;AACL;AACA;AACAD,cAAAA,QAAQ,CAACM,qBAAT;AACD;AACF;;AAEDf,UAAAA,WAAW,CAACuB,cAAZ,CAA2BN,OAA3B,EAAoCT,OAApC;AACD,SAlBD,MAkBO;AACLC,UAAAA,QAAQ,CAACC,KAAT;AACD;AACF,OAxBI;AAyBLE,MAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB;AACpB,YAAIJ,OAAO,GAAGf,QAAQ,CAACwB,OAAD,CAAtB;;AAEA,YAAIT,OAAJ,EAAa;AACX;AACA,iBAAOf,QAAQ,CAACwB,OAAD,CAAf;;AAEA,cAAIjB,WAAJ,EAAiB;AACfA,YAAAA,WAAW,CAACwB,YAAZ,CAAyBP,OAAzB,EADe,CACoB;;AAEnC,gBAAI,CAACD,cAAL,EAAqBhB,WAAW,CAACY,IAAZ,GAHN,CAG0B;AACzC;AACD;;AAED,cAAIH,QAAQ,CAACH,SAAT,EAAJ,EAA0BG,QAAQ,CAACG,IAAT;AAC3B;AACF;AAzCI,KAAP;AA2CD,GAvG4D,CAuG3D;;;AAGFd,EAAAA,WAAW,CAAC2B,MAAZ,GAAqB1B,cAAc,CAAC2B,IAAf,CAAoB,IAApB,EAA0B,IAA1B,CAArB;AACA,SAAO5B,WAAP;AACD","sourcesContent":["import PushManagerFactory from './PushManager';\nimport FullProducerFactory from '../producer';\nimport PartialProducerFactory from '../producer/browser/Partial';\nimport { matching } from '../utils/key/factory';\nimport { forOwn, toString } from '../utils/lang';\nimport logFactory from '../utils/logger';\nimport { PUSH_DISCONNECT, PUSH_CONNECT } from './constants';\nvar log = logFactory('splitio-sync:sync-manager');\n/**\n * Factory of sync manager for browser\n *\n * @param context main client context\n */\n\nexport default function BrowserSyncManagerFactory(mainContext) {\n  // map of user keys to client contexts\n  var contexts = {};\n  var settings = mainContext.get(mainContext.constants.SETTINGS); // call `createInstance` before creating PushManager, since it is in charge of creating the full producer and adding it into the main context.\n\n  var syncManager = createInstance(false, mainContext);\n  var pushManager = settings.streamingEnabled ? PushManagerFactory(mainContext, contexts) : undefined;\n  var mainProducer = mainContext.get(mainContext.constants.PRODUCER);\n\n  function startPolling() {\n    if (!mainProducer.isRunning()) {\n      log.info('Streaming not available. Starting periodic fetch of data.');\n      forOwn(contexts, function (context) {\n        var producer = context.get(context.constants.PRODUCER);\n        producer.start();\n      });\n    } else {\n      log.info('Streaming couldn\\'t connect. Continue periodic fetch of data.');\n    }\n  }\n\n  function stopPollingAndSyncAll() {\n    if (mainProducer.isRunning()) {\n      log.info('PUSH (re)connected. Syncing and stopping periodic fetch of data.'); // if polling, stop\n\n      forOwn(contexts, function (context) {\n        var producer = context.get(context.constants.PRODUCER);\n        producer.stop();\n      });\n    }\n\n    syncAll();\n  }\n\n  function syncAll() {\n    // fetch splits and segments\n    var mainProducer = mainContext.get(mainContext.constants.PRODUCER);\n    mainProducer.synchronizeSplits();\n    forOwn(contexts, function (context) {\n      var producer = context.get(context.constants.PRODUCER);\n      producer.synchronizeMySegments();\n    });\n  }\n  /**\n   * Creates a SyncManager that handles the synchronization of clients (main and shared ones).\n   * Internally, it creates the client producer, adds it into its context, and defines the `start` and `stop` methods that handle synchronization.\n   *\n   * @param {Object} context\n   * @param {boolean} isSharedClient\n   */\n\n\n  function createInstance(isSharedClient, context) {\n    var producer = isSharedClient ? PartialProducerFactory(context) : FullProducerFactory(context);\n    var settings = context.get(context.constants.SETTINGS); // we need to stringify the user key (or matching key) in case it is not an string, to hash and pass as query param for authentication\n\n    var userKey = toString(matching(settings.core.key));\n    context.put(context.constants.PRODUCER, producer);\n    if (contexts[userKey]) log.warn('A client with the same user key has already been created. Only the new instance will be properly synchronized.');\n    contexts[userKey] = context;\n    return {\n      start: function start() {\n        // start syncing\n        if (pushManager) {\n          if (!isSharedClient) {\n            syncAll(); // initial syncAll (only when main client is created)\n\n            pushManager.on(PUSH_CONNECT, stopPollingAndSyncAll);\n            pushManager.on(PUSH_DISCONNECT, startPolling);\n          } else {\n            if (mainProducer.isRunning()) {\n              // if doing polling, we must start the producer periodic fetch of data\n              producer.start();\n            } else {\n              // if not doing polling, we must perform a `producer.synchronizeMySegments` for the initial fetch\n              // of segments since `syncAll` was already executed when starting the main client\n              producer.synchronizeMySegments();\n            }\n          }\n\n          pushManager.startNewClient(userKey, context);\n        } else {\n          producer.start();\n        }\n      },\n      stop: function stop() {\n        var context = contexts[userKey];\n\n        if (context) {\n          // check in case `client.destroy()` has been invoked more than once for the same client\n          delete contexts[userKey];\n\n          if (pushManager) {\n            pushManager.removeClient(userKey); // stop push if stoping main client\n\n            if (!isSharedClient) pushManager.stop(); // We don't reconnect pushmanager when removing a shared client,\n            // since it is more costly than continue listening the channel\n          }\n\n          if (producer.isRunning()) producer.stop();\n        }\n      }\n    };\n  } // For the main client we return a SyncManager with 3 methods: start, stop and shared. The last is used to instantiate \"partial SyncManagers\".\n\n\n  syncManager.shared = createInstance.bind(null, true);\n  return syncManager;\n}"]},"metadata":{},"sourceType":"module"}