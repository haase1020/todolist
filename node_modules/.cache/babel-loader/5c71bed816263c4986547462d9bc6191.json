{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar SegmentCacheInMemory = /*#__PURE__*/function () {\n  function SegmentCacheInMemory(keys) {\n    _classCallCheck(this, SegmentCacheInMemory);\n\n    this.keys = keys;\n    this.flush();\n  }\n\n  _createClass(SegmentCacheInMemory, [{\n    key: \"flush\",\n    value: function flush() {\n      this.segmentCache = {};\n    }\n  }, {\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      this.segmentCache[segmentKey] = true;\n      return true;\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      delete this.segmentCache[segmentKey];\n      return true;\n    }\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     * @NOTE based on the way we use segments in the browser, this way is the best option\n     *\n     * @param {string[]} segmentNames list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var _this = this;\n\n      var isDiff = false;\n      var index;\n      var storedSegmentKeys = Object.keys(this.segmentCache); // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && storedSegmentKeys.length === segmentNames.length) return isDiff; // Quick path\n\n      if (storedSegmentKeys.length !== segmentNames.length) {\n        isDiff = true;\n        this.segmentCache = {};\n        segmentNames.forEach(function (s) {\n          _this.addToSegment(s);\n        });\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && this.isInSegment(segmentNames[index]); index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          this.segmentCache = {};\n          segmentNames.forEach(function (s) {\n            _this.addToSegment(s);\n          });\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      return this.segmentCache[segmentKey] === true;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n  }]);\n\n  return SegmentCacheInMemory;\n}();\n\nexport default SegmentCacheInMemory;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/storage/SegmentCache/InMemory/browser.js"],"names":["_classCallCheck","_createClass","SegmentCacheInMemory","keys","flush","key","value","segmentCache","addToSegment","segmentName","segmentKey","buildSegmentNameKey","removeFromSegment","resetSegments","segmentNames","_this","isDiff","index","storedSegmentKeys","Object","length","forEach","s","isInSegment","setChangeNumber","getChangeNumber","registerSegment","registerSegments","getRegisteredSegments"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar SegmentCacheInMemory = /*#__PURE__*/function () {\n  function SegmentCacheInMemory(keys) {\n    _classCallCheck(this, SegmentCacheInMemory);\n\n    this.keys = keys;\n    this.flush();\n  }\n\n  _createClass(SegmentCacheInMemory, [{\n    key: \"flush\",\n    value: function flush() {\n      this.segmentCache = {};\n    }\n  }, {\n    key: \"addToSegment\",\n    value: function addToSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      this.segmentCache[segmentKey] = true;\n      return true;\n    }\n  }, {\n    key: \"removeFromSegment\",\n    value: function removeFromSegment(segmentName\n    /*, segmentKeys: Array<string>*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      delete this.segmentCache[segmentKey];\n      return true;\n    }\n    /**\n     * Reset (update) the cached list of segments with the given list, removing and adding segments if necessary.\n     * @NOTE based on the way we use segments in the browser, this way is the best option\n     *\n     * @param {string[]} segmentNames list of segment names\n     * @returns boolean indicating if the cache was updated (i.e., given list was different from the cached one)\n     */\n\n  }, {\n    key: \"resetSegments\",\n    value: function resetSegments(segmentNames) {\n      var _this = this;\n\n      var isDiff = false;\n      var index;\n      var storedSegmentKeys = Object.keys(this.segmentCache); // Extreme fast => everything is empty\n\n      if (segmentNames.length === 0 && storedSegmentKeys.length === segmentNames.length) return isDiff; // Quick path\n\n      if (storedSegmentKeys.length !== segmentNames.length) {\n        isDiff = true;\n        this.segmentCache = {};\n        segmentNames.forEach(function (s) {\n          _this.addToSegment(s);\n        });\n      } else {\n        // Slowest path => we need to find at least 1 difference because\n        for (index = 0; index < segmentNames.length && this.isInSegment(segmentNames[index]); index++) {// TODO: why empty statement?\n        }\n\n        if (index < segmentNames.length) {\n          isDiff = true;\n          this.segmentCache = {};\n          segmentNames.forEach(function (s) {\n            _this.addToSegment(s);\n          });\n        }\n      }\n\n      return isDiff;\n    }\n  }, {\n    key: \"isInSegment\",\n    value: function isInSegment(segmentName\n    /*, key: string*/\n    ) {\n      var segmentKey = this.keys.buildSegmentNameKey(segmentName);\n      return this.segmentCache[segmentKey] === true;\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber()\n    /*segmentName: string, changeNumber: number*/\n    {\n      return true;\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber()\n    /*segmentName: string*/\n    {\n      return -1;\n    }\n  }, {\n    key: \"registerSegment\",\n    value: function registerSegment()\n    /*segment: string*/\n    {\n      return false;\n    }\n  }, {\n    key: \"registerSegments\",\n    value: function registerSegments()\n    /*segments: Iterable<string>*/\n    {\n      return false;\n    }\n  }, {\n    key: \"getRegisteredSegments\",\n    value: function getRegisteredSegments() {\n      return [];\n    }\n  }]);\n\n  return SegmentCacheInMemory;\n}();\n\nexport default SegmentCacheInMemory;"]},"metadata":{},"sourceType":"module"}