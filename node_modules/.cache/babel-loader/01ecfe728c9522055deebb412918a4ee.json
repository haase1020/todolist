{"ast":null,"code":"/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\nimport logFactory from '../../utils/logger';\nimport { SplitError } from '../../utils/lang/Errors';\nvar log = logFactory('splitio-producer:my-segments');\nimport mySegmentsFetcher from '../fetcher/MySegments';\nexport default function MySegmentsUpdaterFactory(context) {\n  var _context$getAll = context.getAll(),\n      settings = _context$getAll[context.constants.SETTINGS],\n      readiness = _context$getAll[context.constants.READINESS],\n      storage = _context$getAll[context.constants.STORAGE],\n      metricCollectors = _context$getAll[context.constants.COLLECTORS];\n\n  var segmentsEventEmitter = readiness.segments;\n  var readyOnAlreadyExistentState = true;\n  var startingUp = true; // @TODO if allowing custom storages, handle async execution and wrap errors as SplitErrors to distinguish from user callback errors\n\n  function updateSegments(segments) {\n    // Update the list of segment names available\n    var shouldNotifyUpdate = storage.segments.resetSegments(segments); // Notify update if required\n\n    if (storage.splits.usesSegments() && (shouldNotifyUpdate || readyOnAlreadyExistentState)) {\n      readyOnAlreadyExistentState = false;\n      segmentsEventEmitter.emit(segmentsEventEmitter.SDK_SEGMENTS_ARRIVED);\n    }\n  }\n  /**\n   * MySegments updater returns a promise that resolves with a `false` boolean value if it fails to fetch mySegments or synchronize them with the storage.\n   *\n   * @param {number | undefined} retry current number of retry attemps. this param is only set by SplitChangesUpdater itself.\n   * @param {string[] | undefined} segmentList list of mySegment names to sync in the storage. If the list is `undefined`, it fetches them before syncing in the storage.\n   */\n\n\n  return function MySegmentsUpdater() {\n    var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var segmentList = arguments.length > 1 ? arguments[1] : undefined;\n    var updaterPromise;\n\n    if (segmentList) {\n      // If segmentList is provided, there is no need to fetch mySegments\n      updaterPromise = new Promise(function (res) {\n        updateSegments(segmentList);\n        res();\n      });\n    } else {\n      // NOTE: We only collect metrics on startup.\n      updaterPromise = mySegmentsFetcher(settings, startingUp, metricCollectors).then(function (segments) {\n        // Only when we have downloaded segments completely, we should not keep retrying anymore\n        startingUp = false;\n        updateSegments(segments);\n      });\n    }\n\n    return updaterPromise.catch(function (error) {\n      // handle user callback errors\n      if (!(error instanceof SplitError)) setTimeout(function () {\n        throw error;\n      }, 0);\n\n      if (startingUp && settings.startup.retriesOnFailureBeforeReady > retry) {\n        retry += 1;\n        log.warn(\"Retrying download of segments #\".concat(retry, \". Reason: \").concat(error));\n        return MySegmentsUpdater(retry);\n      } else {\n        startingUp = false;\n      }\n\n      return false; // shouldUpdate = false\n    });\n  };\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/producer/updater/MySegments.js"],"names":["logFactory","SplitError","log","mySegmentsFetcher","MySegmentsUpdaterFactory","context","_context$getAll","getAll","settings","constants","SETTINGS","readiness","READINESS","storage","STORAGE","metricCollectors","COLLECTORS","segmentsEventEmitter","segments","readyOnAlreadyExistentState","startingUp","updateSegments","shouldNotifyUpdate","resetSegments","splits","usesSegments","emit","SDK_SEGMENTS_ARRIVED","MySegmentsUpdater","retry","arguments","length","undefined","segmentList","updaterPromise","Promise","res","then","catch","error","setTimeout","startup","retriesOnFailureBeforeReady","warn","concat"],"mappings":"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","sourcesContent":["/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\nimport logFactory from '../../utils/logger';\nimport { SplitError } from '../../utils/lang/Errors';\nvar log = logFactory('splitio-producer:my-segments');\nimport mySegmentsFetcher from '../fetcher/MySegments';\nexport default function MySegmentsUpdaterFactory(context) {\n  var _context$getAll = context.getAll(),\n      settings = _context$getAll[context.constants.SETTINGS],\n      readiness = _context$getAll[context.constants.READINESS],\n      storage = _context$getAll[context.constants.STORAGE],\n      metricCollectors = _context$getAll[context.constants.COLLECTORS];\n\n  var segmentsEventEmitter = readiness.segments;\n  var readyOnAlreadyExistentState = true;\n  var startingUp = true; // @TODO if allowing custom storages, handle async execution and wrap errors as SplitErrors to distinguish from user callback errors\n\n  function updateSegments(segments) {\n    // Update the list of segment names available\n    var shouldNotifyUpdate = storage.segments.resetSegments(segments); // Notify update if required\n\n    if (storage.splits.usesSegments() && (shouldNotifyUpdate || readyOnAlreadyExistentState)) {\n      readyOnAlreadyExistentState = false;\n      segmentsEventEmitter.emit(segmentsEventEmitter.SDK_SEGMENTS_ARRIVED);\n    }\n  }\n  /**\n   * MySegments updater returns a promise that resolves with a `false` boolean value if it fails to fetch mySegments or synchronize them with the storage.\n   *\n   * @param {number | undefined} retry current number of retry attemps. this param is only set by SplitChangesUpdater itself.\n   * @param {string[] | undefined} segmentList list of mySegment names to sync in the storage. If the list is `undefined`, it fetches them before syncing in the storage.\n   */\n\n\n  return function MySegmentsUpdater() {\n    var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var segmentList = arguments.length > 1 ? arguments[1] : undefined;\n    var updaterPromise;\n\n    if (segmentList) {\n      // If segmentList is provided, there is no need to fetch mySegments\n      updaterPromise = new Promise(function (res) {\n        updateSegments(segmentList);\n        res();\n      });\n    } else {\n      // NOTE: We only collect metrics on startup.\n      updaterPromise = mySegmentsFetcher(settings, startingUp, metricCollectors).then(function (segments) {\n        // Only when we have downloaded segments completely, we should not keep retrying anymore\n        startingUp = false;\n        updateSegments(segments);\n      });\n    }\n\n    return updaterPromise.catch(function (error) {\n      // handle user callback errors\n      if (!(error instanceof SplitError)) setTimeout(function () {\n        throw error;\n      }, 0);\n\n      if (startingUp && settings.startup.retriesOnFailureBeforeReady > retry) {\n        retry += 1;\n        log.warn(\"Retrying download of segments #\".concat(retry, \". Reason: \").concat(error));\n        return MySegmentsUpdater(retry);\n      } else {\n        startingUp = false;\n      }\n\n      return false; // shouldUpdate = false\n    });\n  };\n}"]},"metadata":{},"sourceType":"module"}