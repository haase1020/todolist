{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport getEventSource from '../../services/getEventSource';\nvar VERSION = '1.1';\nvar CONTROL_CHANNEL_REGEX = /^control_/;\n\nvar SSEClient = /*#__PURE__*/function () {\n  _createClass(SSEClient, null, [{\n    key: \"getInstance\",\n\n    /**\n     * Returns a SSEClient instance, or undefined if EventSource is not available.\n     * @param {*} settings Split settings used to get streaming URL\n     */\n    value: function getInstance(settings) {\n      var EventSource = getEventSource();\n      if (EventSource) return new SSEClient(EventSource, settings);\n    } // Instance properties:\n    //  streamingUrl: string\n    //  EventSource: EventSource constructor\n    //  connection: EventSource | undefined\n    //  handler: EventHandler for open, close, error and messages events\n    //  authToken: Object | undefined\n\n  }]);\n\n  function SSEClient(EventSource, settings) {\n    _classCallCheck(this, SSEClient);\n\n    this.EventSource = EventSource;\n    this.streamingUrl = settings.url('/sse');\n    this.reopen = this.reopen.bind(this);\n  }\n\n  _createClass(SSEClient, [{\n    key: \"setEventHandler\",\n    value: function setEventHandler(handler) {\n      this.handler = handler;\n    }\n    /**\n     * Open the connection with a given authToken\n     *\n     * @param {Object} authToken\n     * @throws {TypeError} if `authToken` is undefined\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(authToken) {\n      this.close(); // it closes connection if previously opened\n\n      this.authToken = authToken;\n      var channelsQueryParam = Object.keys(authToken.channels).map(function (channel) {\n        var params = CONTROL_CHANNEL_REGEX.test(channel) ? '[?occupancy=metrics.publishers]' : '';\n        return encodeURIComponent(params + channel);\n      }).join(',');\n      var url = \"\".concat(this.streamingUrl, \"?channels=\").concat(channelsQueryParam, \"&accessToken=\").concat(authToken.token, \"&v=\").concat(VERSION, \"&heartbeats=true\"); // same results using `&heartbeats=false`\n\n      this.connection = new this.EventSource(url);\n\n      if (this.handler) {\n        // no need to check if SSEClient is used only by PushManager\n        this.connection.onopen = this.handler.handleOpen;\n        this.connection.onmessage = this.handler.handleMessage;\n        this.connection.onerror = this.handler.handleError;\n      }\n    }\n    /** Close connection  */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.connection) this.connection.close();\n    }\n    /**\n     * Re-open the connection with the last given authToken.\n     *\n     * @throws {TypeError} if `open` has not been previously called with an authToken\n     */\n\n  }, {\n    key: \"reopen\",\n    value: function reopen() {\n      this.open(this.authToken);\n    }\n  }]);\n\n  return SSEClient;\n}();\n\nexport { SSEClient as default };","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/SSEClient/index.js"],"names":["_classCallCheck","_createClass","getEventSource","VERSION","CONTROL_CHANNEL_REGEX","SSEClient","key","value","getInstance","settings","EventSource","streamingUrl","url","reopen","bind","setEventHandler","handler","open","authToken","close","channelsQueryParam","Object","keys","channels","map","channel","params","test","encodeURIComponent","join","concat","token","connection","onopen","handleOpen","onmessage","handleMessage","onerror","handleError","default"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport getEventSource from '../../services/getEventSource';\nvar VERSION = '1.1';\nvar CONTROL_CHANNEL_REGEX = /^control_/;\n\nvar SSEClient = /*#__PURE__*/function () {\n  _createClass(SSEClient, null, [{\n    key: \"getInstance\",\n\n    /**\n     * Returns a SSEClient instance, or undefined if EventSource is not available.\n     * @param {*} settings Split settings used to get streaming URL\n     */\n    value: function getInstance(settings) {\n      var EventSource = getEventSource();\n      if (EventSource) return new SSEClient(EventSource, settings);\n    } // Instance properties:\n    //  streamingUrl: string\n    //  EventSource: EventSource constructor\n    //  connection: EventSource | undefined\n    //  handler: EventHandler for open, close, error and messages events\n    //  authToken: Object | undefined\n\n  }]);\n\n  function SSEClient(EventSource, settings) {\n    _classCallCheck(this, SSEClient);\n\n    this.EventSource = EventSource;\n    this.streamingUrl = settings.url('/sse');\n    this.reopen = this.reopen.bind(this);\n  }\n\n  _createClass(SSEClient, [{\n    key: \"setEventHandler\",\n    value: function setEventHandler(handler) {\n      this.handler = handler;\n    }\n    /**\n     * Open the connection with a given authToken\n     *\n     * @param {Object} authToken\n     * @throws {TypeError} if `authToken` is undefined\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(authToken) {\n      this.close(); // it closes connection if previously opened\n\n      this.authToken = authToken;\n      var channelsQueryParam = Object.keys(authToken.channels).map(function (channel) {\n        var params = CONTROL_CHANNEL_REGEX.test(channel) ? '[?occupancy=metrics.publishers]' : '';\n        return encodeURIComponent(params + channel);\n      }).join(',');\n      var url = \"\".concat(this.streamingUrl, \"?channels=\").concat(channelsQueryParam, \"&accessToken=\").concat(authToken.token, \"&v=\").concat(VERSION, \"&heartbeats=true\"); // same results using `&heartbeats=false`\n\n      this.connection = new this.EventSource(url);\n\n      if (this.handler) {\n        // no need to check if SSEClient is used only by PushManager\n        this.connection.onopen = this.handler.handleOpen;\n        this.connection.onmessage = this.handler.handleMessage;\n        this.connection.onerror = this.handler.handleError;\n      }\n    }\n    /** Close connection  */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.connection) this.connection.close();\n    }\n    /**\n     * Re-open the connection with the last given authToken.\n     *\n     * @throws {TypeError} if `open` has not been previously called with an authToken\n     */\n\n  }, {\n    key: \"reopen\",\n    value: function reopen() {\n      this.open(this.authToken);\n    }\n  }]);\n\n  return SSEClient;\n}();\n\nexport { SSEClient as default };"]},"metadata":{},"sourceType":"module"}