{"ast":null,"code":"import objectAssign from 'object-assign';\nimport ClientFactory from '../client';\nimport MetricsFactory from '../metrics';\nimport EventsFactory from '../events';\nimport SyncManagerFactory from '../sync';\nimport SignalsListener from '../listeners';\nimport { releaseApiKey } from '../utils/inputValidation';\nimport { STANDALONE_MODE, PRODUCER_MODE, CONSUMER_MODE } from '../utils/constants'; // map of authorizationKeys to syncManagers, to keep a single instance per factory and needed to create shared clients\n\nvar syncManagers = {}; //\n// Create SDK instance based on the provided configurations\n//\n\nfunction SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {\n  var sharedInstance = !!mainClientMetricCollectors;\n  var settings = context.get(context.constants.SETTINGS);\n  var readiness = context.get(context.constants.READINESS);\n  var storage = context.get(context.constants.STORAGE);\n  var statusManager = context.get(context.constants.STATUS_MANAGER); // We are only interested in exposable EventEmitter\n\n  var gate = readiness.gate,\n      splits = readiness.splits,\n      segments = readiness.segments; // Events name\n\n  var SDK_READY = gate.SDK_READY; // Shared instances use parent metrics collectors\n\n  var metrics = sharedInstance ? undefined : MetricsFactory(context); // Shared instances use parent events queue\n\n  var events = sharedInstance ? undefined : EventsFactory(context); // Signal listener only needed for main instances\n\n  var signalsListener = sharedInstance ? undefined : new SignalsListener(context);\n  var syncManager;\n\n  switch (settings.mode) {\n    case PRODUCER_MODE:\n    case STANDALONE_MODE:\n      {\n        context.put(context.constants.COLLECTORS, metrics && metrics.collectors); // We don't fully instantiate syncManager if we are creating a shared instance.\n\n        if (sharedInstance) {\n          syncManager = syncManagers[settings.core.authorizationKey].shared(context);\n        } else {\n          syncManager = SyncManagerFactory(context);\n          syncManagers[settings.core.authorizationKey] = syncManager;\n        }\n\n        break;\n      }\n\n    case CONSUMER_MODE:\n      {\n        context.put(context.constants.READY_FROM_CACHE, true); // For SDK inner workings it's supposed to be ready from cache.\n\n        break;\n      }\n  }\n\n  if (readyTrackers && syncManager && !sharedInstance) {\n    // Only track ready events for non-shared and non-consumer clients\n    var sdkReadyTracker = readyTrackers.sdkReadyTracker,\n        splitsReadyTracker = readyTrackers.splitsReadyTracker,\n        segmentsReadyTracker = readyTrackers.segmentsReadyTracker; // Defered setup of collectors for this task, as it is the only ready latency we store on BE.\n\n    sdkReadyTracker.setCollectorForTask(metrics.collectors);\n    gate.once(SDK_READY, sdkReadyTracker);\n    splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);\n    segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);\n  } // Start background jobs tasks\n\n\n  syncManager && syncManager.start();\n  metrics && metrics.start();\n  events && context.put(context.constants.EVENTS, events) && events.start(); // If no collectors are stored we are on a shared instance, save main one.\n\n  context.put(context.constants.COLLECTORS, mainClientMetricCollectors);\n  var api = objectAssign( // Proto linkage of the EventEmitter to prevent any change\n  Object.create(statusManager), // getTreatment/s & track\n  ClientFactory(context), // Utilities\n  {\n    // Destroy instance\n    destroy: function destroy() {\n      // Stop background jobs\n      syncManager && syncManager.stop();\n      metrics && metrics.stop();\n      events && events.stop(); // Send impressions and events in parallel.\n\n      return Promise.all([metrics && metrics.flush(), events && events.flush()]).then(function () {\n        // Cleanup event listeners\n        readiness.destroy();\n        signalsListener && signalsListener.stop(); // Cleanup storage\n\n        storage.destroy && storage.destroy(); // Mark the factory as destroyed.\n\n        context.put(context.constants.DESTROYED, true); // And release the API Key and SyncManager\n\n        if (!sharedInstance) {\n          releaseApiKey(settings.core.authorizationKey);\n          delete syncManagers[settings.core.authorizationKey];\n        }\n      });\n    }\n  }); // We'll start the signals listener if the client is not a shared instance.\n  // For now, we will only call destroy.\n\n  !sharedInstance && signalsListener.start(api.destroy);\n  return {\n    api: api,\n    metricCollectors: metrics && metrics.collectors\n  };\n}\n\nexport default SplitFactoryOnline;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/factory/online.js"],"names":["objectAssign","ClientFactory","MetricsFactory","EventsFactory","SyncManagerFactory","SignalsListener","releaseApiKey","STANDALONE_MODE","PRODUCER_MODE","CONSUMER_MODE","syncManagers","SplitFactoryOnline","context","readyTrackers","mainClientMetricCollectors","sharedInstance","settings","get","constants","SETTINGS","readiness","READINESS","storage","STORAGE","statusManager","STATUS_MANAGER","gate","splits","segments","SDK_READY","metrics","undefined","events","signalsListener","syncManager","mode","put","COLLECTORS","collectors","core","authorizationKey","shared","READY_FROM_CACHE","sdkReadyTracker","splitsReadyTracker","segmentsReadyTracker","setCollectorForTask","once","SDK_SPLITS_ARRIVED","SDK_SEGMENTS_ARRIVED","start","EVENTS","api","Object","create","destroy","stop","Promise","all","flush","then","DESTROYED","metricCollectors"],"mappings":"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","sourcesContent":["import objectAssign from 'object-assign';\nimport ClientFactory from '../client';\nimport MetricsFactory from '../metrics';\nimport EventsFactory from '../events';\nimport SyncManagerFactory from '../sync';\nimport SignalsListener from '../listeners';\nimport { releaseApiKey } from '../utils/inputValidation';\nimport { STANDALONE_MODE, PRODUCER_MODE, CONSUMER_MODE } from '../utils/constants'; // map of authorizationKeys to syncManagers, to keep a single instance per factory and needed to create shared clients\n\nvar syncManagers = {}; //\n// Create SDK instance based on the provided configurations\n//\n\nfunction SplitFactoryOnline(context, readyTrackers, mainClientMetricCollectors) {\n  var sharedInstance = !!mainClientMetricCollectors;\n  var settings = context.get(context.constants.SETTINGS);\n  var readiness = context.get(context.constants.READINESS);\n  var storage = context.get(context.constants.STORAGE);\n  var statusManager = context.get(context.constants.STATUS_MANAGER); // We are only interested in exposable EventEmitter\n\n  var gate = readiness.gate,\n      splits = readiness.splits,\n      segments = readiness.segments; // Events name\n\n  var SDK_READY = gate.SDK_READY; // Shared instances use parent metrics collectors\n\n  var metrics = sharedInstance ? undefined : MetricsFactory(context); // Shared instances use parent events queue\n\n  var events = sharedInstance ? undefined : EventsFactory(context); // Signal listener only needed for main instances\n\n  var signalsListener = sharedInstance ? undefined : new SignalsListener(context);\n  var syncManager;\n\n  switch (settings.mode) {\n    case PRODUCER_MODE:\n    case STANDALONE_MODE:\n      {\n        context.put(context.constants.COLLECTORS, metrics && metrics.collectors); // We don't fully instantiate syncManager if we are creating a shared instance.\n\n        if (sharedInstance) {\n          syncManager = syncManagers[settings.core.authorizationKey].shared(context);\n        } else {\n          syncManager = SyncManagerFactory(context);\n          syncManagers[settings.core.authorizationKey] = syncManager;\n        }\n\n        break;\n      }\n\n    case CONSUMER_MODE:\n      {\n        context.put(context.constants.READY_FROM_CACHE, true); // For SDK inner workings it's supposed to be ready from cache.\n\n        break;\n      }\n  }\n\n  if (readyTrackers && syncManager && !sharedInstance) {\n    // Only track ready events for non-shared and non-consumer clients\n    var sdkReadyTracker = readyTrackers.sdkReadyTracker,\n        splitsReadyTracker = readyTrackers.splitsReadyTracker,\n        segmentsReadyTracker = readyTrackers.segmentsReadyTracker; // Defered setup of collectors for this task, as it is the only ready latency we store on BE.\n\n    sdkReadyTracker.setCollectorForTask(metrics.collectors);\n    gate.once(SDK_READY, sdkReadyTracker);\n    splits.once(splits.SDK_SPLITS_ARRIVED, splitsReadyTracker);\n    segments.once(segments.SDK_SEGMENTS_ARRIVED, segmentsReadyTracker);\n  } // Start background jobs tasks\n\n\n  syncManager && syncManager.start();\n  metrics && metrics.start();\n  events && context.put(context.constants.EVENTS, events) && events.start(); // If no collectors are stored we are on a shared instance, save main one.\n\n  context.put(context.constants.COLLECTORS, mainClientMetricCollectors);\n  var api = objectAssign( // Proto linkage of the EventEmitter to prevent any change\n  Object.create(statusManager), // getTreatment/s & track\n  ClientFactory(context), // Utilities\n  {\n    // Destroy instance\n    destroy: function destroy() {\n      // Stop background jobs\n      syncManager && syncManager.stop();\n      metrics && metrics.stop();\n      events && events.stop(); // Send impressions and events in parallel.\n\n      return Promise.all([metrics && metrics.flush(), events && events.flush()]).then(function () {\n        // Cleanup event listeners\n        readiness.destroy();\n        signalsListener && signalsListener.stop(); // Cleanup storage\n\n        storage.destroy && storage.destroy(); // Mark the factory as destroyed.\n\n        context.put(context.constants.DESTROYED, true); // And release the API Key and SyncManager\n\n        if (!sharedInstance) {\n          releaseApiKey(settings.core.authorizationKey);\n          delete syncManagers[settings.core.authorizationKey];\n        }\n      });\n    }\n  }); // We'll start the signals listener if the client is not a shared instance.\n  // For now, we will only call destroy.\n\n  !sharedInstance && signalsListener.start(api.destroy);\n  return {\n    api: api,\n    metricCollectors: metrics && metrics.collectors\n  };\n}\n\nexport default SplitFactoryOnline;"]},"metadata":{},"sourceType":"module"}