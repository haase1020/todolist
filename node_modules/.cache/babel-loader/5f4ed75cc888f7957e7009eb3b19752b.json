{"ast":null,"code":"import { STANDALONE_MODE, FILTERS_METADATA } from '../constants';\nimport { validateSplits } from './splits';\nimport logFactory from '../logger';\nvar log = logFactory('');\n\nfunction validateFilterType(filterType) {\n  return FILTERS_METADATA.some(function (filterMetadata) {\n    return filterMetadata.type === filterType;\n  });\n}\n/**\n * Validate, deduplicate and sort a given list of filter values.\n *\n * @param {string} type filter type string used for log messages\n * @param {string[]} values list of values to validate, deduplicate and sort\n * @param {number} maxLength\n * @returns list of valid, unique and alphabetically sorted non-empty strings. The list is empty if `values` param is not a non-empty array or all its values are invalid.\n *\n * @throws Error if the sanitized list exceeds the length indicated by `maxLength`\n */\n\n\nfunction validateSplitFilter(type, values, maxLength) {\n  // validate and remove invalid and duplicated values\n  var result = validateSplits(values, 'Factory instantiation', \"\".concat(type, \" filter\"), \"\".concat(type, \" filter value\"));\n\n  if (result) {\n    // check max length\n    if (result.length > maxLength) throw new Error(\"\".concat(maxLength, \" unique values can be specified at most for '\").concat(type, \"' filter. You passed \").concat(result.length, \". Please consider reducing the amount or using other filter.\")); // sort values\n\n    result.sort();\n  }\n\n  return result || []; // returns empty array if `result` is `false`\n}\n/**\n * Returns a string representing the URL encoded query component of /splitChanges URL.\n *\n * The possible formats of the query string are:\n *  - null: if all filters are empty\n *  - '&names=<comma-separated-values>': if only `byPrefix` filter is undefined\n *  - '&prefixes=<comma-separated-values>': if only `byName` filter is undefined\n *  - '&names=<comma-separated-values>&prefixes=<comma-separated-values>': if no one is undefined\n *\n * @param {Object} groupedFilters object of filters. Each filter must be a list of valid, unique and ordered string values.\n * @returns null or string with the `split filter query` component of the URL.\n */\n\n\nfunction queryStringBuilder(groupedFilters) {\n  var queryParams = [];\n  FILTERS_METADATA.forEach(function (_ref) {\n    var type = _ref.type,\n        queryParam = _ref.queryParam;\n    var filter = groupedFilters[type];\n    if (filter.length > 0) queryParams.push(queryParam + filter.map(function (value) {\n      return encodeURIComponent(value);\n    }).join(','));\n  });\n  return queryParams.length > 0 ? '&' + queryParams.join('&') : null;\n}\n/**\n * Validates `splitFilters` configuration object and parses it into a query string for filtering splits on `/splitChanges` fetch.\n *\n * @param {Object|undefined} splitFilters split filters configuration param\n * @param {string} mode settings mode\n * @returns it returns an object with the following properties:\n *  - `validFilters`: the validated `splitFilters` configuration object defined by the user.\n *  - `queryString`: the parsed split filter query. it is null if all filters are invalid or all values in filters are invalid.\n *  - `groupedFilters`: list of values grouped by filter type.\n *\n * @throws Error if the some of the grouped list of values per filter exceeds the max allowed length\n */\n\n\nexport default function validateSplitFilters(splitFilters, mode) {\n  // Validation result schema\n  var res = {\n    validFilters: [],\n    queryString: null,\n    groupedFilters: {}\n  }; // do nothing if `splitFilters` param is not a non-empty array or mode is not STANDALONE\n\n  if (!splitFilters) return res; // Warn depending on the mode\n\n  if (mode !== STANDALONE_MODE) {\n    log.warn(\"Factory instantiation: split filters have been configured but will have no effect if mode is not '\".concat(STANDALONE_MODE, \"', since synchronization is being deferred to an external tool.\"));\n    return res;\n  } // Check collection type\n\n\n  if (!Array.isArray(splitFilters) || splitFilters.length === 0) {\n    log.warn('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.');\n    return res;\n  } // Validate filters and group their values by filter type inside `groupedFilters` object\n\n\n  FILTERS_METADATA.forEach(function (metadata) {\n    res.groupedFilters[metadata.type] = [];\n  }); // Assign the valid filters to the output of the validator by using filter function\n\n  res.validFilters = splitFilters.filter(function (filter, index) {\n    if (filter && validateFilterType(filter.type) && Array.isArray(filter.values)) {\n      res.groupedFilters[filter.type] = res.groupedFilters[filter.type].concat(filter.values);\n      return true;\n    } else {\n      log.warn(\"Factory instantiation: split filter at position '\".concat(index, \"' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'.\"));\n    }\n\n    return false;\n  }); // By filter type, remove invalid and duplicated values and order them\n\n  FILTERS_METADATA.forEach(function (_ref2) {\n    var type = _ref2.type,\n        maxLength = _ref2.maxLength;\n    if (res.groupedFilters[type].length > 0) res.groupedFilters[type] = validateSplitFilter(type, res.groupedFilters[type], maxLength);\n  }); // build query string\n\n  res.queryString = queryStringBuilder(res.groupedFilters);\n  log.debug(\"Factory instantiation: splits filtering criteria is '\".concat(res.queryString, \"'.\"));\n  return res;\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/utils/inputValidation/splitFilters.js"],"names":["STANDALONE_MODE","FILTERS_METADATA","validateSplits","logFactory","log","validateFilterType","filterType","some","filterMetadata","type","validateSplitFilter","values","maxLength","result","concat","length","Error","sort","queryStringBuilder","groupedFilters","queryParams","forEach","_ref","queryParam","filter","push","map","value","encodeURIComponent","join","validateSplitFilters","splitFilters","mode","res","validFilters","queryString","warn","Array","isArray","metadata","index","_ref2","debug"],"mappings":"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","sourcesContent":["import { STANDALONE_MODE, FILTERS_METADATA } from '../constants';\nimport { validateSplits } from './splits';\nimport logFactory from '../logger';\nvar log = logFactory('');\n\nfunction validateFilterType(filterType) {\n  return FILTERS_METADATA.some(function (filterMetadata) {\n    return filterMetadata.type === filterType;\n  });\n}\n/**\n * Validate, deduplicate and sort a given list of filter values.\n *\n * @param {string} type filter type string used for log messages\n * @param {string[]} values list of values to validate, deduplicate and sort\n * @param {number} maxLength\n * @returns list of valid, unique and alphabetically sorted non-empty strings. The list is empty if `values` param is not a non-empty array or all its values are invalid.\n *\n * @throws Error if the sanitized list exceeds the length indicated by `maxLength`\n */\n\n\nfunction validateSplitFilter(type, values, maxLength) {\n  // validate and remove invalid and duplicated values\n  var result = validateSplits(values, 'Factory instantiation', \"\".concat(type, \" filter\"), \"\".concat(type, \" filter value\"));\n\n  if (result) {\n    // check max length\n    if (result.length > maxLength) throw new Error(\"\".concat(maxLength, \" unique values can be specified at most for '\").concat(type, \"' filter. You passed \").concat(result.length, \". Please consider reducing the amount or using other filter.\")); // sort values\n\n    result.sort();\n  }\n\n  return result || []; // returns empty array if `result` is `false`\n}\n/**\n * Returns a string representing the URL encoded query component of /splitChanges URL.\n *\n * The possible formats of the query string are:\n *  - null: if all filters are empty\n *  - '&names=<comma-separated-values>': if only `byPrefix` filter is undefined\n *  - '&prefixes=<comma-separated-values>': if only `byName` filter is undefined\n *  - '&names=<comma-separated-values>&prefixes=<comma-separated-values>': if no one is undefined\n *\n * @param {Object} groupedFilters object of filters. Each filter must be a list of valid, unique and ordered string values.\n * @returns null or string with the `split filter query` component of the URL.\n */\n\n\nfunction queryStringBuilder(groupedFilters) {\n  var queryParams = [];\n  FILTERS_METADATA.forEach(function (_ref) {\n    var type = _ref.type,\n        queryParam = _ref.queryParam;\n    var filter = groupedFilters[type];\n    if (filter.length > 0) queryParams.push(queryParam + filter.map(function (value) {\n      return encodeURIComponent(value);\n    }).join(','));\n  });\n  return queryParams.length > 0 ? '&' + queryParams.join('&') : null;\n}\n/**\n * Validates `splitFilters` configuration object and parses it into a query string for filtering splits on `/splitChanges` fetch.\n *\n * @param {Object|undefined} splitFilters split filters configuration param\n * @param {string} mode settings mode\n * @returns it returns an object with the following properties:\n *  - `validFilters`: the validated `splitFilters` configuration object defined by the user.\n *  - `queryString`: the parsed split filter query. it is null if all filters are invalid or all values in filters are invalid.\n *  - `groupedFilters`: list of values grouped by filter type.\n *\n * @throws Error if the some of the grouped list of values per filter exceeds the max allowed length\n */\n\n\nexport default function validateSplitFilters(splitFilters, mode) {\n  // Validation result schema\n  var res = {\n    validFilters: [],\n    queryString: null,\n    groupedFilters: {}\n  }; // do nothing if `splitFilters` param is not a non-empty array or mode is not STANDALONE\n\n  if (!splitFilters) return res; // Warn depending on the mode\n\n  if (mode !== STANDALONE_MODE) {\n    log.warn(\"Factory instantiation: split filters have been configured but will have no effect if mode is not '\".concat(STANDALONE_MODE, \"', since synchronization is being deferred to an external tool.\"));\n    return res;\n  } // Check collection type\n\n\n  if (!Array.isArray(splitFilters) || splitFilters.length === 0) {\n    log.warn('Factory instantiation: splitFilters configuration must be a non-empty array of filter objects.');\n    return res;\n  } // Validate filters and group their values by filter type inside `groupedFilters` object\n\n\n  FILTERS_METADATA.forEach(function (metadata) {\n    res.groupedFilters[metadata.type] = [];\n  }); // Assign the valid filters to the output of the validator by using filter function\n\n  res.validFilters = splitFilters.filter(function (filter, index) {\n    if (filter && validateFilterType(filter.type) && Array.isArray(filter.values)) {\n      res.groupedFilters[filter.type] = res.groupedFilters[filter.type].concat(filter.values);\n      return true;\n    } else {\n      log.warn(\"Factory instantiation: split filter at position '\".concat(index, \"' is invalid. It must be an object with a valid filter type ('byName' or 'byPrefix') and a list of 'values'.\"));\n    }\n\n    return false;\n  }); // By filter type, remove invalid and duplicated values and order them\n\n  FILTERS_METADATA.forEach(function (_ref2) {\n    var type = _ref2.type,\n        maxLength = _ref2.maxLength;\n    if (res.groupedFilters[type].length > 0) res.groupedFilters[type] = validateSplitFilter(type, res.groupedFilters[type], maxLength);\n  }); // build query string\n\n  res.queryString = queryStringBuilder(res.groupedFilters);\n  log.debug(\"Factory instantiation: splits filtering criteria is '\".concat(res.queryString, \"'.\"));\n  return res;\n}"]},"metadata":{},"sourceType":"module"}