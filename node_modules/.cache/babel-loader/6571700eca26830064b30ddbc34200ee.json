{"ast":null,"code":"import objectAssign from 'object-assign';\nimport ClientFactory from './client';\nimport { validateAttributes, validateEvent, validateEventValue, validateEventProperties, validateKey, validateSplit, validateSplits, validateTrafficType, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\nimport { startsWith } from '../utils/lang';\nimport { STORAGE_REDIS, CONTROL, CONTROL_WITH_CONFIG } from '../utils/constants';\n/**\n * We will validate the input before actually executing the client methods. We should \"guard\" the client here,\n * while not polluting the \"real\" implementation of those methods.\n */\n\nfunction ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {\n  var settings = context.get(context.constants.SETTINGS);\n  var isStorageSync = settings.storage.type !== STORAGE_REDIS; // instantiate the client\n\n  var client = ClientFactory(context); // Keep a reference to the original methods\n\n  var clientGetTreatment = client.getTreatment;\n  var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;\n  var clientGetTreatments = client.getTreatments;\n  var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;\n  var clientTrack = client.track;\n  /**\n   * Avoid repeating this validations code\n   */\n\n  function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {\n    var multi = startsWith(methodName, 'getTreatments');\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, methodName);\n    var splitOrSplits = multi ? validateSplits(maybeSplitOrSplits, methodName) : validateSplit(maybeSplitOrSplits, methodName);\n    var attributes = validateAttributes(maybeAttributes, methodName);\n    var isOperational = validateIfDestroyed(context);\n    validateIfReady(context, methodName);\n    var valid = isOperational && key && splitOrSplits && attributes !== false;\n    return {\n      valid: valid,\n      key: key,\n      splitOrSplits: splitOrSplits,\n      attributes: attributes\n    };\n  }\n\n  client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatment');\n\n    if (params.valid) {\n      return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return CONTROL;\n      return Promise.resolve(CONTROL);\n    }\n  };\n\n  client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatmentWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return objectAssign({}, CONTROL_WITH_CONFIG);\n      return Promise.resolve(objectAssign({}, CONTROL_WITH_CONFIG));\n    }\n  };\n\n  client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatments');\n\n    if (params.valid) {\n      return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var res = {};\n      if (params.splitOrSplits) params.splitOrSplits.forEach(function (split) {\n        return res[split] = CONTROL;\n      });\n      if (isStorageSync) return res;\n      return Promise.resolve(res);\n    }\n  };\n\n  client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatmentsWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var res = {};\n      if (params.splitOrSplits) params.splitOrSplits.forEach(function (split) {\n        return res[split] = objectAssign({}, CONTROL_WITH_CONFIG);\n      });\n      if (isStorageSync) return res;\n      return Promise.resolve(res);\n    }\n  };\n\n  client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, 'track');\n    var tt = isTTBinded ? maybeTT : validateTrafficType(maybeTT, 'track');\n    var event = validateEvent(maybeEvent, 'track');\n    var eventValue = validateEventValue(maybeEventValue, 'track');\n\n    var _validateEventPropert = validateEventProperties(maybeProperties, 'track'),\n        properties = _validateEventPropert.properties,\n        size = _validateEventPropert.size;\n\n    var isOperational = validateIfDestroyed(context);\n\n    if (isOperational && key && tt && event && eventValue !== false && properties !== false) {\n      return clientTrack(key, tt, event, eventValue, properties, size);\n    } else {\n      if (isStorageSync) return false;\n      return Promise.resolve(false);\n    }\n  };\n\n  return client;\n}\n\nexport default ClientInputValidationLayer;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/client/inputValidation.js"],"names":["objectAssign","ClientFactory","validateAttributes","validateEvent","validateEventValue","validateEventProperties","validateKey","validateSplit","validateSplits","validateTrafficType","validateIfDestroyed","validateIfReady","startsWith","STORAGE_REDIS","CONTROL","CONTROL_WITH_CONFIG","ClientInputValidationLayer","context","isKeyBinded","isTTBinded","settings","get","constants","SETTINGS","isStorageSync","storage","type","client","clientGetTreatment","getTreatment","clientGetTreatmentWithConfig","getTreatmentWithConfig","clientGetTreatments","getTreatments","clientGetTreatmentsWithConfig","getTreatmentsWithConfig","clientTrack","track","validateEvaluationParams","maybeKey","maybeSplitOrSplits","maybeAttributes","methodName","multi","key","splitOrSplits","attributes","isOperational","valid","maybeSplit","params","Promise","resolve","maybeSplits","res","forEach","split","maybeTT","maybeEvent","maybeEventValue","maybeProperties","tt","event","eventValue","_validateEventPropert","properties","size"],"mappings":"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","sourcesContent":["import objectAssign from 'object-assign';\nimport ClientFactory from './client';\nimport { validateAttributes, validateEvent, validateEventValue, validateEventProperties, validateKey, validateSplit, validateSplits, validateTrafficType, validateIfDestroyed, validateIfReady } from '../utils/inputValidation';\nimport { startsWith } from '../utils/lang';\nimport { STORAGE_REDIS, CONTROL, CONTROL_WITH_CONFIG } from '../utils/constants';\n/**\n * We will validate the input before actually executing the client methods. We should \"guard\" the client here,\n * while not polluting the \"real\" implementation of those methods.\n */\n\nfunction ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {\n  var settings = context.get(context.constants.SETTINGS);\n  var isStorageSync = settings.storage.type !== STORAGE_REDIS; // instantiate the client\n\n  var client = ClientFactory(context); // Keep a reference to the original methods\n\n  var clientGetTreatment = client.getTreatment;\n  var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;\n  var clientGetTreatments = client.getTreatments;\n  var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;\n  var clientTrack = client.track;\n  /**\n   * Avoid repeating this validations code\n   */\n\n  function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {\n    var multi = startsWith(methodName, 'getTreatments');\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, methodName);\n    var splitOrSplits = multi ? validateSplits(maybeSplitOrSplits, methodName) : validateSplit(maybeSplitOrSplits, methodName);\n    var attributes = validateAttributes(maybeAttributes, methodName);\n    var isOperational = validateIfDestroyed(context);\n    validateIfReady(context, methodName);\n    var valid = isOperational && key && splitOrSplits && attributes !== false;\n    return {\n      valid: valid,\n      key: key,\n      splitOrSplits: splitOrSplits,\n      attributes: attributes\n    };\n  }\n\n  client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatment');\n\n    if (params.valid) {\n      return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return CONTROL;\n      return Promise.resolve(CONTROL);\n    }\n  };\n\n  client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatmentWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      if (isStorageSync) return objectAssign({}, CONTROL_WITH_CONFIG);\n      return Promise.resolve(objectAssign({}, CONTROL_WITH_CONFIG));\n    }\n  };\n\n  client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatments');\n\n    if (params.valid) {\n      return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var res = {};\n      if (params.splitOrSplits) params.splitOrSplits.forEach(function (split) {\n        return res[split] = CONTROL;\n      });\n      if (isStorageSync) return res;\n      return Promise.resolve(res);\n    }\n  };\n\n  client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {\n    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatmentsWithConfig');\n\n    if (params.valid) {\n      return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);\n    } else {\n      var res = {};\n      if (params.splitOrSplits) params.splitOrSplits.forEach(function (split) {\n        return res[split] = objectAssign({}, CONTROL_WITH_CONFIG);\n      });\n      if (isStorageSync) return res;\n      return Promise.resolve(res);\n    }\n  };\n\n  client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {\n    var key = isKeyBinded ? maybeKey : validateKey(maybeKey, 'track');\n    var tt = isTTBinded ? maybeTT : validateTrafficType(maybeTT, 'track');\n    var event = validateEvent(maybeEvent, 'track');\n    var eventValue = validateEventValue(maybeEventValue, 'track');\n\n    var _validateEventPropert = validateEventProperties(maybeProperties, 'track'),\n        properties = _validateEventPropert.properties,\n        size = _validateEventPropert.size;\n\n    var isOperational = validateIfDestroyed(context);\n\n    if (isOperational && key && tt && event && eventValue !== false && properties !== false) {\n      return clientTrack(key, tt, event, eventValue, properties, size);\n    } else {\n      if (isStorageSync) return false;\n      return Promise.resolve(false);\n    }\n  };\n\n  return client;\n}\n\nexport default ClientInputValidationLayer;"]},"metadata":{},"sourceType":"module"}