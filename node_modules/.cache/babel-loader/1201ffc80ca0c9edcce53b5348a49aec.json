{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport logFactory from '../../utils/logger';\nimport { uniq } from '../../utils/lang';\nimport { SPLIT_IMPRESSION, SPLIT_EVENT } from '../../utils/constants';\nvar log = logFactory('splitio-split-to-ga');\n\nvar SplitToGa = /*#__PURE__*/function () {\n  _createClass(SplitToGa, null, [{\n    key: \"defaultMapper\",\n    // Default mapper function.\n    value: function defaultMapper(_ref) {\n      var type = _ref.type,\n          payload = _ref.payload;\n\n      switch (type) {\n        case SPLIT_IMPRESSION:\n          return {\n            hitType: 'event',\n            eventCategory: 'split-impression',\n            eventAction: 'Evaluate ' + payload.impression.feature,\n            eventLabel: 'Treatment: ' + payload.impression.treatment + '. Targeting rule: ' + payload.impression.label + '.',\n            nonInteraction: true\n          };\n\n        case SPLIT_EVENT:\n          return {\n            hitType: 'event',\n            eventCategory: 'split-event',\n            eventAction: payload.eventTypeId,\n            eventValue: payload.value,\n            nonInteraction: true\n          };\n      }\n\n      return null;\n    } // Util to access ga command queue, accounting for the possibility that it has been renamed.\n\n  }, {\n    key: \"getGa\",\n    value: function getGa() {\n      return typeof window !== 'undefined' ? window[window['GoogleAnalyticsObject'] || 'ga'] : undefined;\n    }\n    /**\n     * Validates if a given object is a UniversalAnalytics.FieldsObject instance, and logs a warning if not.\n     * It checks that the object contains a `hitType`, since it is the minimal field required to send the hit\n     * and avoid the GA error `No hit type specified. Aborting hit.`.\n     * Other validations (e.g., an `event` hitType must have a `eventCategory` and `eventAction`) are handled\n     * and logged (as warnings or errors depending the case) by GA debugger, but the hit is sent anyway.\n     *\n     * @param {UniversalAnalytics.FieldsObject} fieldsObject object to validate.\n     * @returns {boolean} Whether the data instance is a valid FieldsObject or not.\n     */\n\n  }, {\n    key: \"validateFieldsObject\",\n    value: function validateFieldsObject(fieldsObject) {\n      if (fieldsObject && fieldsObject.hitType) return true;\n      log.warn('your custom mapper returned an invalid FieldsObject instance. It must be an object with at least a `hitType` field.');\n      return false;\n    }\n  }]);\n\n  function SplitToGa(options) {\n    _classCallCheck(this, SplitToGa); // Check if `ga` object is available\n\n\n    if (typeof SplitToGa.getGa() !== 'function') {\n      log.warn('`ga` command queue not found. No hits will be sent.'); // Return an empty object to avoid creating a SplitToGa instance\n\n      return {};\n    }\n\n    this.trackerNames = SplitToGa.defaultTrackerNames;\n\n    if (options) {\n      if (typeof options.filter === 'function') this.filter = options.filter;\n      if (typeof options.mapper === 'function') this.mapper = options.mapper; // We strip off duplicated values if we received a `trackerNames` param.\n      // We don't warn if a tracker does not exist, since the user might create it after the SDK is initialized.\n      // Note: GA allows to create and get trackers using a string or number as tracker name, and does nothing if other types are used.\n\n      if (Array.isArray(options.trackerNames)) this.trackerNames = uniq(options.trackerNames); // No need to validate `impressions` and `events` flags. Any other value than `false` is ignored.\n\n      this.impressions = options.impressions;\n      this.events = options.events;\n    }\n\n    log.info('Started Split-to-GA integration');\n  }\n\n  _createClass(SplitToGa, [{\n    key: \"queue\",\n    value: function queue(data) {\n      // access ga command queue via `getGa` method, accounting for the possibility that\n      // the global `ga` reference was not yet mutated by analytics.js.\n      var ga = SplitToGa.getGa();\n\n      if (ga) {\n        if (this.impressions === false && data.type === SPLIT_IMPRESSION) return;\n        if (this.events === false && data.type === SPLIT_EVENT) return;\n        var fieldsObject;\n\n        try {\n          // only try/catch filter and mapper, which might be defined by the user\n          // filter\n          if (this.filter && !this.filter(data)) return; // map data into a FieldsObject instance\n\n          fieldsObject = SplitToGa.defaultMapper(data);\n\n          if (this.mapper) {\n            fieldsObject = this.mapper(data, fieldsObject); // don't send the hit if it is falsy or invalid\n\n            if (!fieldsObject || !SplitToGa.validateFieldsObject(fieldsObject)) return;\n          }\n        } catch (err) {\n          log.warn(\"SplitToGa queue method threw: \".concat(err, \". No hit was sent.\"));\n          return;\n        } // send the hit\n\n\n        this.trackerNames.forEach(function (trackerName) {\n          var sendCommand = trackerName ? \"\".concat(trackerName, \".send\") : 'send'; // mark the hit as a Split one to avoid the loop.\n\n          fieldsObject.splitHit = true; // Send to GA using our reference to the GA object.\n\n          ga(sendCommand, fieldsObject);\n        });\n      }\n    }\n  }]);\n\n  return SplitToGa;\n}(); // A falsy object represents the default tracker\n\n\nSplitToGa.defaultTrackerNames = [''];\nexport default SplitToGa;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/integrations/ga/SplitToGa.js"],"names":["_classCallCheck","_createClass","logFactory","uniq","SPLIT_IMPRESSION","SPLIT_EVENT","log","SplitToGa","key","value","defaultMapper","_ref","type","payload","hitType","eventCategory","eventAction","impression","feature","eventLabel","treatment","label","nonInteraction","eventTypeId","eventValue","getGa","window","undefined","validateFieldsObject","fieldsObject","warn","options","trackerNames","defaultTrackerNames","filter","mapper","Array","isArray","impressions","events","info","queue","data","ga","err","concat","forEach","trackerName","sendCommand","splitHit"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport logFactory from '../../utils/logger';\nimport { uniq } from '../../utils/lang';\nimport { SPLIT_IMPRESSION, SPLIT_EVENT } from '../../utils/constants';\nvar log = logFactory('splitio-split-to-ga');\n\nvar SplitToGa = /*#__PURE__*/function () {\n  _createClass(SplitToGa, null, [{\n    key: \"defaultMapper\",\n    // Default mapper function.\n    value: function defaultMapper(_ref) {\n      var type = _ref.type,\n          payload = _ref.payload;\n\n      switch (type) {\n        case SPLIT_IMPRESSION:\n          return {\n            hitType: 'event',\n            eventCategory: 'split-impression',\n            eventAction: 'Evaluate ' + payload.impression.feature,\n            eventLabel: 'Treatment: ' + payload.impression.treatment + '. Targeting rule: ' + payload.impression.label + '.',\n            nonInteraction: true\n          };\n\n        case SPLIT_EVENT:\n          return {\n            hitType: 'event',\n            eventCategory: 'split-event',\n            eventAction: payload.eventTypeId,\n            eventValue: payload.value,\n            nonInteraction: true\n          };\n      }\n\n      return null;\n    } // Util to access ga command queue, accounting for the possibility that it has been renamed.\n\n  }, {\n    key: \"getGa\",\n    value: function getGa() {\n      return typeof window !== 'undefined' ? window[window['GoogleAnalyticsObject'] || 'ga'] : undefined;\n    }\n    /**\n     * Validates if a given object is a UniversalAnalytics.FieldsObject instance, and logs a warning if not.\n     * It checks that the object contains a `hitType`, since it is the minimal field required to send the hit\n     * and avoid the GA error `No hit type specified. Aborting hit.`.\n     * Other validations (e.g., an `event` hitType must have a `eventCategory` and `eventAction`) are handled\n     * and logged (as warnings or errors depending the case) by GA debugger, but the hit is sent anyway.\n     *\n     * @param {UniversalAnalytics.FieldsObject} fieldsObject object to validate.\n     * @returns {boolean} Whether the data instance is a valid FieldsObject or not.\n     */\n\n  }, {\n    key: \"validateFieldsObject\",\n    value: function validateFieldsObject(fieldsObject) {\n      if (fieldsObject && fieldsObject.hitType) return true;\n      log.warn('your custom mapper returned an invalid FieldsObject instance. It must be an object with at least a `hitType` field.');\n      return false;\n    }\n  }]);\n\n  function SplitToGa(options) {\n    _classCallCheck(this, SplitToGa);\n\n    // Check if `ga` object is available\n    if (typeof SplitToGa.getGa() !== 'function') {\n      log.warn('`ga` command queue not found. No hits will be sent.'); // Return an empty object to avoid creating a SplitToGa instance\n\n      return {};\n    }\n\n    this.trackerNames = SplitToGa.defaultTrackerNames;\n\n    if (options) {\n      if (typeof options.filter === 'function') this.filter = options.filter;\n      if (typeof options.mapper === 'function') this.mapper = options.mapper; // We strip off duplicated values if we received a `trackerNames` param.\n      // We don't warn if a tracker does not exist, since the user might create it after the SDK is initialized.\n      // Note: GA allows to create and get trackers using a string or number as tracker name, and does nothing if other types are used.\n\n      if (Array.isArray(options.trackerNames)) this.trackerNames = uniq(options.trackerNames); // No need to validate `impressions` and `events` flags. Any other value than `false` is ignored.\n\n      this.impressions = options.impressions;\n      this.events = options.events;\n    }\n\n    log.info('Started Split-to-GA integration');\n  }\n\n  _createClass(SplitToGa, [{\n    key: \"queue\",\n    value: function queue(data) {\n      // access ga command queue via `getGa` method, accounting for the possibility that\n      // the global `ga` reference was not yet mutated by analytics.js.\n      var ga = SplitToGa.getGa();\n\n      if (ga) {\n        if (this.impressions === false && data.type === SPLIT_IMPRESSION) return;\n        if (this.events === false && data.type === SPLIT_EVENT) return;\n        var fieldsObject;\n\n        try {\n          // only try/catch filter and mapper, which might be defined by the user\n          // filter\n          if (this.filter && !this.filter(data)) return; // map data into a FieldsObject instance\n\n          fieldsObject = SplitToGa.defaultMapper(data);\n\n          if (this.mapper) {\n            fieldsObject = this.mapper(data, fieldsObject); // don't send the hit if it is falsy or invalid\n\n            if (!fieldsObject || !SplitToGa.validateFieldsObject(fieldsObject)) return;\n          }\n        } catch (err) {\n          log.warn(\"SplitToGa queue method threw: \".concat(err, \". No hit was sent.\"));\n          return;\n        } // send the hit\n\n\n        this.trackerNames.forEach(function (trackerName) {\n          var sendCommand = trackerName ? \"\".concat(trackerName, \".send\") : 'send'; // mark the hit as a Split one to avoid the loop.\n\n          fieldsObject.splitHit = true; // Send to GA using our reference to the GA object.\n\n          ga(sendCommand, fieldsObject);\n        });\n      }\n    }\n  }]);\n\n  return SplitToGa;\n}(); // A falsy object represents the default tracker\n\n\nSplitToGa.defaultTrackerNames = [''];\nexport default SplitToGa;"]},"metadata":{},"sourceType":"module"}