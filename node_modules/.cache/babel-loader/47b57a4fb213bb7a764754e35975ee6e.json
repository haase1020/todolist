{"ast":null,"code":"import logFactory from '../utils/logger';\nvar log = logFactory('splitio-events');\nimport tracker from '../utils/timeTracker';\nimport repeat from '../utils/fn/repeat';\nimport eventsService from '../services/events';\nimport eventsBulkRequest from '../services/events/bulk';\n\nvar EventsFactory = function EventsFactory(context) {\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n\n  var pushEvents = function pushEvents() {\n    if (storage.events.isEmpty()) return Promise.resolve();\n    log.info(\"Pushing \".concat(storage.events.state().length, \" queued events.\"));\n    var latencyTrackerStop = tracker.start(tracker.TaskNames.EVENTS_PUSH);\n    var json = JSON.stringify(storage.events.toJSON());\n\n    var wrapUpCb = function wrapUpCb() {\n      return latencyTrackerStop();\n    };\n\n    storage.events.clear(); // we always clear the queue.\n\n    return eventsService(eventsBulkRequest(settings, {\n      body: json\n    })).then(wrapUpCb).catch(wrapUpCb);\n  };\n\n  var stopEventPublisherTimeout = false;\n  var stopEventsPublisher = false;\n\n  var startEventsPublisher = function startEventsPublisher() {\n    return stopEventsPublisher = repeat(function (schedulePublisher) {\n      return pushEvents().then(function () {\n        return schedulePublisher();\n      });\n    }, settings.scheduler.eventsPushRate);\n  };\n\n  return {\n    start: function start() {\n      // On the browser there may be a wish to wait an specific amount of seconds before the first push.\n      if (settings.startup.eventsFirstPushWindow > 0) {\n        stopEventPublisherTimeout = setTimeout(startEventsPublisher, settings.startup.eventsFirstPushWindow);\n      } else {\n        startEventsPublisher();\n      }\n    },\n    flush: function flush() {\n      return pushEvents();\n    },\n    stop: function stop() {\n      stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);\n      stopEventsPublisher && stopEventsPublisher();\n    },\n    flushAndResetTimer: function flushAndResetTimer() {\n      // Reset the timer and push the events.\n      log.info('Flushing events and reseting timer.');\n      stopEventsPublisher && stopEventsPublisher.reset();\n      return pushEvents();\n    }\n  };\n};\n\nexport default EventsFactory;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/events/index.js"],"names":["logFactory","log","tracker","repeat","eventsService","eventsBulkRequest","EventsFactory","context","settings","get","constants","SETTINGS","storage","STORAGE","pushEvents","events","isEmpty","Promise","resolve","info","concat","state","length","latencyTrackerStop","start","TaskNames","EVENTS_PUSH","json","JSON","stringify","toJSON","wrapUpCb","clear","body","then","catch","stopEventPublisherTimeout","stopEventsPublisher","startEventsPublisher","schedulePublisher","scheduler","eventsPushRate","startup","eventsFirstPushWindow","setTimeout","flush","stop","clearTimeout","flushAndResetTimer","reset"],"mappings":"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","sourcesContent":["import logFactory from '../utils/logger';\nvar log = logFactory('splitio-events');\nimport tracker from '../utils/timeTracker';\nimport repeat from '../utils/fn/repeat';\nimport eventsService from '../services/events';\nimport eventsBulkRequest from '../services/events/bulk';\n\nvar EventsFactory = function EventsFactory(context) {\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n\n  var pushEvents = function pushEvents() {\n    if (storage.events.isEmpty()) return Promise.resolve();\n    log.info(\"Pushing \".concat(storage.events.state().length, \" queued events.\"));\n    var latencyTrackerStop = tracker.start(tracker.TaskNames.EVENTS_PUSH);\n    var json = JSON.stringify(storage.events.toJSON());\n\n    var wrapUpCb = function wrapUpCb() {\n      return latencyTrackerStop();\n    };\n\n    storage.events.clear(); // we always clear the queue.\n\n    return eventsService(eventsBulkRequest(settings, {\n      body: json\n    })).then(wrapUpCb).catch(wrapUpCb);\n  };\n\n  var stopEventPublisherTimeout = false;\n  var stopEventsPublisher = false;\n\n  var startEventsPublisher = function startEventsPublisher() {\n    return stopEventsPublisher = repeat(function (schedulePublisher) {\n      return pushEvents().then(function () {\n        return schedulePublisher();\n      });\n    }, settings.scheduler.eventsPushRate);\n  };\n\n  return {\n    start: function start() {\n      // On the browser there may be a wish to wait an specific amount of seconds before the first push.\n      if (settings.startup.eventsFirstPushWindow > 0) {\n        stopEventPublisherTimeout = setTimeout(startEventsPublisher, settings.startup.eventsFirstPushWindow);\n      } else {\n        startEventsPublisher();\n      }\n    },\n    flush: function flush() {\n      return pushEvents();\n    },\n    stop: function stop() {\n      stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);\n      stopEventsPublisher && stopEventsPublisher();\n    },\n    flushAndResetTimer: function flushAndResetTimer() {\n      // Reset the timer and push the events.\n      log.info('Flushing events and reseting timer.');\n      stopEventsPublisher && stopEventsPublisher.reset();\n      return pushEvents();\n    }\n  };\n};\n\nexport default EventsFactory;"]},"metadata":{},"sourceType":"module"}