{"ast":null,"code":"import objectAssign from 'object-assign';\nimport logFactory from '../utils/logger';\nimport thenable from '../utils/promise/thenable';\nvar log = logFactory('splitio-client:event-tracker');\n\nfunction EventTracker(context) {\n  var collector = context.get(context.constants.STORAGE).events;\n  var integrationsManager = context.get(context.constants.INTEGRATIONS_MANAGER, true);\n\n  function queueEventsCallback(eventData, tracked) {\n    var eventTypeId = eventData.eventTypeId,\n        trafficTypeName = eventData.trafficTypeName,\n        key = eventData.key,\n        value = eventData.value,\n        timestamp = eventData.timestamp,\n        properties = eventData.properties; // Logging every prop would be too much.\n\n    var msg = \"event of type \\\"\".concat(eventTypeId, \"\\\" for traffic type \\\"\").concat(trafficTypeName, \"\\\". Key: \").concat(key, \". Value: \").concat(value, \". Timestamp: \").concat(timestamp, \". \").concat(properties ? 'With properties.' : 'With no properties.');\n\n    if (tracked) {\n      log.info(\"Successfully qeued \".concat(msg));\n\n      if (integrationsManager) {\n        // Wrap in a timeout because we don't want it to be blocking.\n        setTimeout(function () {\n          // copy of event, to avoid unexpected behaviour if modified by integrations\n          var eventDataCopy = objectAssign({}, eventData);\n          if (eventData.properties) eventDataCopy.properties = objectAssign({}, eventData.properties); // integrationsManager does not throw errors (they are internally handled by each integration module)\n\n          integrationsManager.handleEvent(eventDataCopy);\n        }, 0);\n      }\n    } else {\n      log.warn(\"Failed to queue \".concat(msg));\n    }\n\n    return tracked;\n  }\n\n  return {\n    track: function track(eventData, size) {\n      var tracked = collector.track(eventData, size);\n\n      if (thenable(tracked)) {\n        return tracked.then(queueEventsCallback.bind(null, eventData));\n      } else {\n        return queueEventsCallback(eventData, tracked);\n      }\n    }\n  };\n}\n\nexport default EventTracker;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/trackers/event.js"],"names":["objectAssign","logFactory","thenable","log","EventTracker","context","collector","get","constants","STORAGE","events","integrationsManager","INTEGRATIONS_MANAGER","queueEventsCallback","eventData","tracked","eventTypeId","trafficTypeName","key","value","timestamp","properties","msg","concat","info","setTimeout","eventDataCopy","handleEvent","warn","track","size","then","bind"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,eAAzB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,QAAP,MAAqB,2BAArB;AACA,IAAIC,GAAG,GAAGF,UAAU,CAAC,8BAAD,CAApB;;AAEA,SAASG,YAAT,CAAsBC,OAAtB,EAA+B;AAC7B,MAAIC,SAAS,GAAGD,OAAO,CAACE,GAAR,CAAYF,OAAO,CAACG,SAAR,CAAkBC,OAA9B,EAAuCC,MAAvD;AACA,MAAIC,mBAAmB,GAAGN,OAAO,CAACE,GAAR,CAAYF,OAAO,CAACG,SAAR,CAAkBI,oBAA9B,EAAoD,IAApD,CAA1B;;AAEA,WAASC,mBAAT,CAA6BC,SAA7B,EAAwCC,OAAxC,EAAiD;AAC/C,QAAIC,WAAW,GAAGF,SAAS,CAACE,WAA5B;AAAA,QACIC,eAAe,GAAGH,SAAS,CAACG,eADhC;AAAA,QAEIC,GAAG,GAAGJ,SAAS,CAACI,GAFpB;AAAA,QAGIC,KAAK,GAAGL,SAAS,CAACK,KAHtB;AAAA,QAIIC,SAAS,GAAGN,SAAS,CAACM,SAJ1B;AAAA,QAKIC,UAAU,GAAGP,SAAS,CAACO,UAL3B,CAD+C,CAMR;;AAEvC,QAAIC,GAAG,GAAG,mBAAmBC,MAAnB,CAA0BP,WAA1B,EAAuC,wBAAvC,EAAiEO,MAAjE,CAAwEN,eAAxE,EAAyF,WAAzF,EAAsGM,MAAtG,CAA6GL,GAA7G,EAAkH,WAAlH,EAA+HK,MAA/H,CAAsIJ,KAAtI,EAA6I,eAA7I,EAA8JI,MAA9J,CAAqKH,SAArK,EAAgL,IAAhL,EAAsLG,MAAtL,CAA6LF,UAAU,GAAG,kBAAH,GAAwB,qBAA/N,CAAV;;AAEA,QAAIN,OAAJ,EAAa;AACXZ,MAAAA,GAAG,CAACqB,IAAJ,CAAS,sBAAsBD,MAAtB,CAA6BD,GAA7B,CAAT;;AAEA,UAAIX,mBAAJ,EAAyB;AACvB;AACAc,QAAAA,UAAU,CAAC,YAAY;AACrB;AACA,cAAIC,aAAa,GAAG1B,YAAY,CAAC,EAAD,EAAKc,SAAL,CAAhC;AACA,cAAIA,SAAS,CAACO,UAAd,EAA0BK,aAAa,CAACL,UAAd,GAA2BrB,YAAY,CAAC,EAAD,EAAKc,SAAS,CAACO,UAAf,CAAvC,CAHL,CAGwE;;AAE7FV,UAAAA,mBAAmB,CAACgB,WAApB,CAAgCD,aAAhC;AACD,SANS,EAMP,CANO,CAAV;AAOD;AACF,KAbD,MAaO;AACLvB,MAAAA,GAAG,CAACyB,IAAJ,CAAS,mBAAmBL,MAAnB,CAA0BD,GAA1B,CAAT;AACD;;AAED,WAAOP,OAAP;AACD;;AAED,SAAO;AACLc,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAef,SAAf,EAA0BgB,IAA1B,EAAgC;AACrC,UAAIf,OAAO,GAAGT,SAAS,CAACuB,KAAV,CAAgBf,SAAhB,EAA2BgB,IAA3B,CAAd;;AAEA,UAAI5B,QAAQ,CAACa,OAAD,CAAZ,EAAuB;AACrB,eAAOA,OAAO,CAACgB,IAAR,CAAalB,mBAAmB,CAACmB,IAApB,CAAyB,IAAzB,EAA+BlB,SAA/B,CAAb,CAAP;AACD,OAFD,MAEO;AACL,eAAOD,mBAAmB,CAACC,SAAD,EAAYC,OAAZ,CAA1B;AACD;AACF;AATI,GAAP;AAWD;;AAED,eAAeX,YAAf","sourcesContent":["import objectAssign from 'object-assign';\nimport logFactory from '../utils/logger';\nimport thenable from '../utils/promise/thenable';\nvar log = logFactory('splitio-client:event-tracker');\n\nfunction EventTracker(context) {\n  var collector = context.get(context.constants.STORAGE).events;\n  var integrationsManager = context.get(context.constants.INTEGRATIONS_MANAGER, true);\n\n  function queueEventsCallback(eventData, tracked) {\n    var eventTypeId = eventData.eventTypeId,\n        trafficTypeName = eventData.trafficTypeName,\n        key = eventData.key,\n        value = eventData.value,\n        timestamp = eventData.timestamp,\n        properties = eventData.properties; // Logging every prop would be too much.\n\n    var msg = \"event of type \\\"\".concat(eventTypeId, \"\\\" for traffic type \\\"\").concat(trafficTypeName, \"\\\". Key: \").concat(key, \". Value: \").concat(value, \". Timestamp: \").concat(timestamp, \". \").concat(properties ? 'With properties.' : 'With no properties.');\n\n    if (tracked) {\n      log.info(\"Successfully qeued \".concat(msg));\n\n      if (integrationsManager) {\n        // Wrap in a timeout because we don't want it to be blocking.\n        setTimeout(function () {\n          // copy of event, to avoid unexpected behaviour if modified by integrations\n          var eventDataCopy = objectAssign({}, eventData);\n          if (eventData.properties) eventDataCopy.properties = objectAssign({}, eventData.properties); // integrationsManager does not throw errors (they are internally handled by each integration module)\n\n          integrationsManager.handleEvent(eventDataCopy);\n        }, 0);\n      }\n    } else {\n      log.warn(\"Failed to queue \".concat(msg));\n    }\n\n    return tracked;\n  }\n\n  return {\n    track: function track(eventData, size) {\n      var tracked = collector.track(eventData, size);\n\n      if (thenable(tracked)) {\n        return tracked.then(queueEventsCallback.bind(null, eventData));\n      } else {\n        return queueEventsCallback(eventData, tracked);\n      }\n    }\n  };\n}\n\nexport default EventTracker;"]},"metadata":{},"sourceType":"module"}