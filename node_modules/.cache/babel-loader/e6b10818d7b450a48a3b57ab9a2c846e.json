{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Backoff from '../../utils/backoff';\n/**\n * SplitUpdateWorker class\n */\n\nvar SplitUpdateWorker = /*#__PURE__*/function () {\n  /**\n   * @param {Object} splitStorage splits cache\n   * @param {Object} splitProducer node producer or full browser producer\n   * @param {Object} splitsEventEmitter\n   */\n  function SplitUpdateWorker(splitStorage, splitProducer, splitsEventEmitter) {\n    _classCallCheck(this, SplitUpdateWorker);\n\n    this.splitStorage = splitStorage;\n    this.splitProducer = splitProducer;\n    this.maxChangeNumber = 0;\n    this.splitsEventEmitter = splitsEventEmitter;\n    this.put = this.put.bind(this);\n    this.killSplit = this.killSplit.bind(this);\n    this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleSplitUpdateCall);\n  } // Private method\n  // Preconditions: this.splitProducer.isSynchronizingSplits === false\n\n\n  _createClass(SplitUpdateWorker, [{\n    key: \"__handleSplitUpdateCall\",\n    value: function __handleSplitUpdateCall() {\n      var _this = this;\n\n      if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {\n        this.handleNewEvent = false;\n        this.splitProducer.synchronizeSplits().then(function () {\n          if (_this.handleNewEvent) {\n            _this.__handleSplitUpdateCall();\n          } else {\n            _this.backoff.scheduleCall();\n          }\n        });\n      }\n    }\n    /**\n     * Invoked by NotificationProcessor on SPLIT_UPDATE event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(changeNumber) {\n      var currentChangeNumber = this.splitStorage.getChangeNumber();\n      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n      this.maxChangeNumber = changeNumber;\n      this.handleNewEvent = true;\n      this.backoff.reset();\n      if (this.splitProducer.isSynchronizingSplits()) return;\n\n      this.__handleSplitUpdateCall();\n    }\n    /**\n     * Invoked by NotificationProcessor on SPLIT_KILL event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     * @param {string} splitName name of split to kill\n     * @param {string} defaultTreatment default treatment value\n     */\n\n  }, {\n    key: \"killSplit\",\n    value: function killSplit(changeNumber, splitName, defaultTreatment) {\n      var _this2 = this; // @TODO handle retry due to errors in storage, once we allow the definition of custom async storages\n\n\n      this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function (updated) {\n        // trigger an SDK_UPDATE if Split was killed locally\n        if (updated) _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true); // queues the SplitChanges fetch (only if changeNumber is newer)\n\n        _this2.put(changeNumber);\n      });\n    }\n  }]);\n\n  return SplitUpdateWorker;\n}();\n\nexport { SplitUpdateWorker as default };","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/SplitUpdateWorker/index.js"],"names":["_classCallCheck","_createClass","Backoff","SplitUpdateWorker","splitStorage","splitProducer","splitsEventEmitter","maxChangeNumber","put","bind","killSplit","__handleSplitUpdateCall","backoff","key","value","_this","getChangeNumber","handleNewEvent","synchronizeSplits","then","scheduleCall","changeNumber","currentChangeNumber","reset","isSynchronizingSplits","splitName","defaultTreatment","_this2","killLocally","updated","emit","SDK_SPLITS_ARRIVED","default"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,YAAP,MAAyB,wCAAzB;AACA,OAAOC,OAAP,MAAoB,qBAApB;AACA;;;;AAIA,IAAIC,iBAAiB,GAAG,aAAa,YAAY;AAC/C;;;;;AAKA,WAASA,iBAAT,CAA2BC,YAA3B,EAAyCC,aAAzC,EAAwDC,kBAAxD,EAA4E;AAC1EN,IAAAA,eAAe,CAAC,IAAD,EAAOG,iBAAP,CAAf;;AAEA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKE,eAAL,GAAuB,CAAvB;AACA,SAAKD,kBAAL,GAA0BA,kBAA1B;AACA,SAAKE,GAAL,GAAW,KAAKA,GAAL,CAASC,IAAT,CAAc,IAAd,CAAX;AACA,SAAKC,SAAL,GAAiB,KAAKA,SAAL,CAAeD,IAAf,CAAoB,IAApB,CAAjB;AACA,SAAKE,uBAAL,GAA+B,KAAKA,uBAAL,CAA6BF,IAA7B,CAAkC,IAAlC,CAA/B;AACA,SAAKG,OAAL,GAAe,IAAIV,OAAJ,CAAY,KAAKS,uBAAjB,CAAf;AACD,GAjB8C,CAiB7C;AACF;;;AAGAV,EAAAA,YAAY,CAACE,iBAAD,EAAoB,CAAC;AAC/BU,IAAAA,GAAG,EAAE,yBAD0B;AAE/BC,IAAAA,KAAK,EAAE,SAASH,uBAAT,GAAmC;AACxC,UAAII,KAAK,GAAG,IAAZ;;AAEA,UAAI,KAAKR,eAAL,GAAuB,KAAKH,YAAL,CAAkBY,eAAlB,EAA3B,EAAgE;AAC9D,aAAKC,cAAL,GAAsB,KAAtB;AACA,aAAKZ,aAAL,CAAmBa,iBAAnB,GAAuCC,IAAvC,CAA4C,YAAY;AACtD,cAAIJ,KAAK,CAACE,cAAV,EAA0B;AACxBF,YAAAA,KAAK,CAACJ,uBAAN;AACD,WAFD,MAEO;AACLI,YAAAA,KAAK,CAACH,OAAN,CAAcQ,YAAd;AACD;AACF,SAND;AAOD;AACF;AACD;;;;;;AAhB+B,GAAD,EAsB7B;AACDP,IAAAA,GAAG,EAAE,KADJ;AAEDC,IAAAA,KAAK,EAAE,SAASN,GAAT,CAAaa,YAAb,EAA2B;AAChC,UAAIC,mBAAmB,GAAG,KAAKlB,YAAL,CAAkBY,eAAlB,EAA1B;AACA,UAAIK,YAAY,IAAIC,mBAAhB,IAAuCD,YAAY,IAAI,KAAKd,eAAhE,EAAiF;AACjF,WAAKA,eAAL,GAAuBc,YAAvB;AACA,WAAKJ,cAAL,GAAsB,IAAtB;AACA,WAAKL,OAAL,CAAaW,KAAb;AACA,UAAI,KAAKlB,aAAL,CAAmBmB,qBAAnB,EAAJ,EAAgD;;AAEhD,WAAKb,uBAAL;AACD;AACD;;;;;;;;AAZC,GAtB6B,EA0C7B;AACDE,IAAAA,GAAG,EAAE,WADJ;AAEDC,IAAAA,KAAK,EAAE,SAASJ,SAAT,CAAmBW,YAAnB,EAAiCI,SAAjC,EAA4CC,gBAA5C,EAA8D;AACnE,UAAIC,MAAM,GAAG,IAAb,CADmE,CAGnE;;;AACA,WAAKvB,YAAL,CAAkBwB,WAAlB,CAA8BH,SAA9B,EAAyCC,gBAAzC,EAA2DL,YAA3D,EAAyEF,IAAzE,CAA8E,UAAUU,OAAV,EAAmB;AAC/F;AACA,YAAIA,OAAJ,EAAaF,MAAM,CAACrB,kBAAP,CAA0BwB,IAA1B,CAA+BH,MAAM,CAACrB,kBAAP,CAA0ByB,kBAAzD,EAA6E,IAA7E,EAFkF,CAEE;;AAEjGJ,QAAAA,MAAM,CAACnB,GAAP,CAAWa,YAAX;AACD,OALD;AAMD;AAZA,GA1C6B,CAApB,CAAZ;;AAyDA,SAAOlB,iBAAP;AACD,CA/EoC,EAArC;;AAiFA,SAASA,iBAAiB,IAAI6B,OAA9B","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Backoff from '../../utils/backoff';\n/**\n * SplitUpdateWorker class\n */\n\nvar SplitUpdateWorker = /*#__PURE__*/function () {\n  /**\n   * @param {Object} splitStorage splits cache\n   * @param {Object} splitProducer node producer or full browser producer\n   * @param {Object} splitsEventEmitter\n   */\n  function SplitUpdateWorker(splitStorage, splitProducer, splitsEventEmitter) {\n    _classCallCheck(this, SplitUpdateWorker);\n\n    this.splitStorage = splitStorage;\n    this.splitProducer = splitProducer;\n    this.maxChangeNumber = 0;\n    this.splitsEventEmitter = splitsEventEmitter;\n    this.put = this.put.bind(this);\n    this.killSplit = this.killSplit.bind(this);\n    this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleSplitUpdateCall);\n  } // Private method\n  // Preconditions: this.splitProducer.isSynchronizingSplits === false\n\n\n  _createClass(SplitUpdateWorker, [{\n    key: \"__handleSplitUpdateCall\",\n    value: function __handleSplitUpdateCall() {\n      var _this = this;\n\n      if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {\n        this.handleNewEvent = false;\n        this.splitProducer.synchronizeSplits().then(function () {\n          if (_this.handleNewEvent) {\n            _this.__handleSplitUpdateCall();\n          } else {\n            _this.backoff.scheduleCall();\n          }\n        });\n      }\n    }\n    /**\n     * Invoked by NotificationProcessor on SPLIT_UPDATE event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(changeNumber) {\n      var currentChangeNumber = this.splitStorage.getChangeNumber();\n      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n      this.maxChangeNumber = changeNumber;\n      this.handleNewEvent = true;\n      this.backoff.reset();\n      if (this.splitProducer.isSynchronizingSplits()) return;\n\n      this.__handleSplitUpdateCall();\n    }\n    /**\n     * Invoked by NotificationProcessor on SPLIT_KILL event\n     *\n     * @param {number} changeNumber change number of the SPLIT_UPDATE notification\n     * @param {string} splitName name of split to kill\n     * @param {string} defaultTreatment default treatment value\n     */\n\n  }, {\n    key: \"killSplit\",\n    value: function killSplit(changeNumber, splitName, defaultTreatment) {\n      var _this2 = this;\n\n      // @TODO handle retry due to errors in storage, once we allow the definition of custom async storages\n      this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function (updated) {\n        // trigger an SDK_UPDATE if Split was killed locally\n        if (updated) _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true); // queues the SplitChanges fetch (only if changeNumber is newer)\n\n        _this2.put(changeNumber);\n      });\n    }\n  }]);\n\n  return SplitUpdateWorker;\n}();\n\nexport { SplitUpdateWorker as default };"]},"metadata":{},"sourceType":"module"}