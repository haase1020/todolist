{"ast":null,"code":"import { PUSH_CONNECT, PUSH_DISCONNECT, PUSH_DISABLED, ControlTypes } from '../constants';\nvar CONTROL_PRI_CHANNEL_REGEX = /control_pri$/;\nexport default function notificationKeeperFactory(feedbackLoopEmitter) {\n  var occupancyTimestamp = -1;\n  var hasPublishers = true; // false if the number of publishers is equal to 0 in the last OCCUPANCY notification from CHANNEL_PRI\n\n  var controlTimestamp = -1;\n  var hasResumed = true; // false if last CONTROL event was STREAMING_PAUSED or STREAMING_DISABLED\n\n  return {\n    handleOpen: function handleOpen() {\n      feedbackLoopEmitter.emit(PUSH_CONNECT);\n    },\n    isStreamingUp: function isStreamingUp() {\n      return hasResumed && hasPublishers;\n    },\n    handleOccupancyEvent: function handleOccupancyEvent(publishers, channel, timestamp) {\n      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > occupancyTimestamp) {\n        occupancyTimestamp = timestamp;\n\n        if (hasResumed) {\n          if (publishers === 0 && hasPublishers) {\n            feedbackLoopEmitter.emit(PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec\n          } else if (publishers !== 0 && !hasPublishers) {\n            feedbackLoopEmitter.emit(PUSH_CONNECT); // notify(STREAMING_UP) in spec\n          } // nothing to do when hasResumed === false:\n          // streaming is already down for `publishers === 0`, and cannot be up for `publishers !== 0`\n\n        }\n\n        hasPublishers = publishers !== 0;\n      }\n    },\n    handleControlEvent: function handleControlEvent(controlType, channel, timestamp) {\n      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > controlTimestamp) {\n        controlTimestamp = timestamp;\n\n        if (controlType === ControlTypes.STREAMING_DISABLED) {\n          feedbackLoopEmitter.emit(PUSH_DISABLED);\n        } else if (hasPublishers) {\n          if (controlType === ControlTypes.STREAMING_PAUSED && hasResumed) {\n            feedbackLoopEmitter.emit(PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec\n          } else if (controlType === ControlTypes.STREAMING_RESUMED && !hasResumed) {\n            feedbackLoopEmitter.emit(PUSH_CONNECT); // notify(STREAMING_UP) in spec\n          } // nothing to do when hasPublishers === false:\n          // streaming is already down for `STREAMING_PAUSED`, and cannot be up for `STREAMING_RESUMED`\n\n        }\n\n        hasResumed = controlType === ControlTypes.STREAMING_RESUMED;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/SSEHandler/NotificationKeeper.js"],"names":["PUSH_CONNECT","PUSH_DISCONNECT","PUSH_DISABLED","ControlTypes","CONTROL_PRI_CHANNEL_REGEX","notificationKeeperFactory","feedbackLoopEmitter","occupancyTimestamp","hasPublishers","controlTimestamp","hasResumed","handleOpen","emit","isStreamingUp","handleOccupancyEvent","publishers","channel","timestamp","test","handleControlEvent","controlType","STREAMING_DISABLED","STREAMING_PAUSED","STREAMING_RESUMED"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,eAAvB,EAAwCC,aAAxC,EAAuDC,YAAvD,QAA2E,cAA3E;AACA,IAAIC,yBAAyB,GAAG,cAAhC;AACA,eAAe,SAASC,yBAAT,CAAmCC,mBAAnC,EAAwD;AACrE,MAAIC,kBAAkB,GAAG,CAAC,CAA1B;AACA,MAAIC,aAAa,GAAG,IAApB,CAFqE,CAE3C;;AAE1B,MAAIC,gBAAgB,GAAG,CAAC,CAAxB;AACA,MAAIC,UAAU,GAAG,IAAjB,CALqE,CAK9C;;AAEvB,SAAO;AACLC,IAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB;AAChCL,MAAAA,mBAAmB,CAACM,IAApB,CAAyBZ,YAAzB;AACD,KAHI;AAILa,IAAAA,aAAa,EAAE,SAASA,aAAT,GAAyB;AACtC,aAAOH,UAAU,IAAIF,aAArB;AACD,KANI;AAOLM,IAAAA,oBAAoB,EAAE,SAASA,oBAAT,CAA8BC,UAA9B,EAA0CC,OAA1C,EAAmDC,SAAnD,EAA8D;AAClF,UAAIb,yBAAyB,CAACc,IAA1B,CAA+BF,OAA/B,KAA2CC,SAAS,GAAGV,kBAA3D,EAA+E;AAC7EA,QAAAA,kBAAkB,GAAGU,SAArB;;AAEA,YAAIP,UAAJ,EAAgB;AACd,cAAIK,UAAU,KAAK,CAAf,IAAoBP,aAAxB,EAAuC;AACrCF,YAAAA,mBAAmB,CAACM,IAApB,CAAyBX,eAAzB,EADqC,CACM;AAC5C,WAFD,MAEO,IAAIc,UAAU,KAAK,CAAf,IAAoB,CAACP,aAAzB,EAAwC;AAC7CF,YAAAA,mBAAmB,CAACM,IAApB,CAAyBZ,YAAzB,EAD6C,CACL;AACzC,WALa,CAKZ;AACF;;AAED;;AAEDQ,QAAAA,aAAa,GAAGO,UAAU,KAAK,CAA/B;AACD;AACF,KAvBI;AAwBLI,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BC,WAA5B,EAAyCJ,OAAzC,EAAkDC,SAAlD,EAA6D;AAC/E,UAAIb,yBAAyB,CAACc,IAA1B,CAA+BF,OAA/B,KAA2CC,SAAS,GAAGR,gBAA3D,EAA6E;AAC3EA,QAAAA,gBAAgB,GAAGQ,SAAnB;;AAEA,YAAIG,WAAW,KAAKjB,YAAY,CAACkB,kBAAjC,EAAqD;AACnDf,UAAAA,mBAAmB,CAACM,IAApB,CAAyBV,aAAzB;AACD,SAFD,MAEO,IAAIM,aAAJ,EAAmB;AACxB,cAAIY,WAAW,KAAKjB,YAAY,CAACmB,gBAA7B,IAAiDZ,UAArD,EAAiE;AAC/DJ,YAAAA,mBAAmB,CAACM,IAApB,CAAyBX,eAAzB,EAD+D,CACpB;AAC5C,WAFD,MAEO,IAAImB,WAAW,KAAKjB,YAAY,CAACoB,iBAA7B,IAAkD,CAACb,UAAvD,EAAmE;AACxEJ,YAAAA,mBAAmB,CAACM,IAApB,CAAyBZ,YAAzB,EADwE,CAChC;AACzC,WALuB,CAKtB;AACF;;AAED;;AAEDU,QAAAA,UAAU,GAAGU,WAAW,KAAKjB,YAAY,CAACoB,iBAA1C;AACD;AACF;AA1CI,GAAP;AA4CD","sourcesContent":["import { PUSH_CONNECT, PUSH_DISCONNECT, PUSH_DISABLED, ControlTypes } from '../constants';\nvar CONTROL_PRI_CHANNEL_REGEX = /control_pri$/;\nexport default function notificationKeeperFactory(feedbackLoopEmitter) {\n  var occupancyTimestamp = -1;\n  var hasPublishers = true; // false if the number of publishers is equal to 0 in the last OCCUPANCY notification from CHANNEL_PRI\n\n  var controlTimestamp = -1;\n  var hasResumed = true; // false if last CONTROL event was STREAMING_PAUSED or STREAMING_DISABLED\n\n  return {\n    handleOpen: function handleOpen() {\n      feedbackLoopEmitter.emit(PUSH_CONNECT);\n    },\n    isStreamingUp: function isStreamingUp() {\n      return hasResumed && hasPublishers;\n    },\n    handleOccupancyEvent: function handleOccupancyEvent(publishers, channel, timestamp) {\n      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > occupancyTimestamp) {\n        occupancyTimestamp = timestamp;\n\n        if (hasResumed) {\n          if (publishers === 0 && hasPublishers) {\n            feedbackLoopEmitter.emit(PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec\n          } else if (publishers !== 0 && !hasPublishers) {\n            feedbackLoopEmitter.emit(PUSH_CONNECT); // notify(STREAMING_UP) in spec\n          } // nothing to do when hasResumed === false:\n          // streaming is already down for `publishers === 0`, and cannot be up for `publishers !== 0`\n\n        }\n\n        hasPublishers = publishers !== 0;\n      }\n    },\n    handleControlEvent: function handleControlEvent(controlType, channel, timestamp) {\n      if (CONTROL_PRI_CHANNEL_REGEX.test(channel) && timestamp > controlTimestamp) {\n        controlTimestamp = timestamp;\n\n        if (controlType === ControlTypes.STREAMING_DISABLED) {\n          feedbackLoopEmitter.emit(PUSH_DISABLED);\n        } else if (hasPublishers) {\n          if (controlType === ControlTypes.STREAMING_PAUSED && hasResumed) {\n            feedbackLoopEmitter.emit(PUSH_DISCONNECT); // notify(STREAMING_DOWN) in spec\n          } else if (controlType === ControlTypes.STREAMING_RESUMED && !hasResumed) {\n            feedbackLoopEmitter.emit(PUSH_CONNECT); // notify(STREAMING_UP) in spec\n          } // nothing to do when hasPublishers === false:\n          // streaming is already down for `STREAMING_PAUSED`, and cannot be up for `STREAMING_RESUMED`\n\n        }\n\n        hasResumed = controlType === ControlTypes.STREAMING_RESUMED;\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}