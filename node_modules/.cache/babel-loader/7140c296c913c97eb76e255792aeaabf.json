{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Backoff from '../../utils/backoff';\n/**\n * MySegmentUpdateWorker class\n */\n\nvar MySegmentUpdateWorker = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {Object} mySegmentsStorage\n   * @param {Object} mySegmentsProducer\n   */\n  function MySegmentUpdateWorker(mySegmentsStorage, mySegmentsProducer) {\n    _classCallCheck(this, MySegmentUpdateWorker);\n\n    this.mySegmentsStorage = mySegmentsStorage;\n    this.mySegmentsProducer = mySegmentsProducer;\n    this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events\n\n    this.segmentList = undefined; // keeps the segmentList (if included in payload) from the queued event with maximum changeNumber\n\n    this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber\n\n    this.put = this.put.bind(this);\n    this.__handleMySegmentUpdateCall = this.__handleMySegmentUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleMySegmentUpdateCall);\n  } // Private method\n  // Preconditions: this.mySegmentsProducer.isSynchronizingMySegments === false\n  // @TODO update this block similar to SplitUpdateWorker, once `/mySegments` endpoint provides the changeNumber\n\n\n  _createClass(MySegmentUpdateWorker, [{\n    key: \"__handleMySegmentUpdateCall\",\n    value: function __handleMySegmentUpdateCall() {\n      var _this = this;\n\n      if (this.maxChangeNumber > this.currentChangeNumber) {\n        this.handleNewEvent = false;\n        var currentMaxChangeNumber = this.maxChangeNumber;\n        this.mySegmentsProducer.synchronizeMySegments(this.segmentList).then(function (result) {\n          if (result !== false) // Unlike `Split\\SegmentUpdateWorker`, we cannot use `mySegmentsStorage.getChangeNumber` since `/mySegments` endpoint doesn't provide this value.\n            _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.\n\n          if (_this.handleNewEvent) {\n            _this.__handleMySegmentUpdateCall();\n          } else {\n            _this.backoff.scheduleCall();\n          }\n        });\n      }\n    }\n    /**\n     * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event\n     *\n     * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification\n     * @param {string[] | undefined} segmentList might be undefined\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(changeNumber, segmentList) {\n      // @TODO uncomment next line once `/mySegments` endpoint provides the changeNumber\n      // const currentChangeNumber = this.mySegmentsStorage.getChangeNumber();\n      if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n      this.maxChangeNumber = changeNumber;\n      this.handleNewEvent = true;\n      this.backoff.reset();\n      this.segmentList = segmentList;\n      if (this.mySegmentsProducer.isSynchronizingMySegments()) return;\n\n      this.__handleMySegmentUpdateCall();\n    }\n  }]);\n\n  return MySegmentUpdateWorker;\n}();\n\nexport { MySegmentUpdateWorker as default };","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/SegmentUpdateWorker/browser.js"],"names":["_classCallCheck","_createClass","Backoff","MySegmentUpdateWorker","mySegmentsStorage","mySegmentsProducer","maxChangeNumber","segmentList","undefined","currentChangeNumber","put","bind","__handleMySegmentUpdateCall","backoff","key","value","_this","handleNewEvent","currentMaxChangeNumber","synchronizeMySegments","then","result","Math","max","scheduleCall","changeNumber","reset","isSynchronizingMySegments","default"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,YAAP,MAAyB,wCAAzB;AACA,OAAOC,OAAP,MAAoB,qBAApB;AACA;;;;AAIA,IAAIC,qBAAqB,GAAG,aAAa,YAAY;AACnD;;;;;AAKA,WAASA,qBAAT,CAA+BC,iBAA/B,EAAkDC,kBAAlD,EAAsE;AACpEL,IAAAA,eAAe,CAAC,IAAD,EAAOG,qBAAP,CAAf;;AAEA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,eAAL,GAAuB,CAAvB,CALoE,CAK1C;;AAE1B,SAAKC,WAAL,GAAmBC,SAAnB,CAPoE,CAOtC;;AAE9B,SAAKC,mBAAL,GAA2B,CAAC,CAA5B,CAToE,CASrC;;AAE/B,SAAKC,GAAL,GAAW,KAAKA,GAAL,CAASC,IAAT,CAAc,IAAd,CAAX;AACA,SAAKC,2BAAL,GAAmC,KAAKA,2BAAL,CAAiCD,IAAjC,CAAsC,IAAtC,CAAnC;AACA,SAAKE,OAAL,GAAe,IAAIX,OAAJ,CAAY,KAAKU,2BAAjB,CAAf;AACD,GApBkD,CAoBjD;AACF;AACA;;;AAGAX,EAAAA,YAAY,CAACE,qBAAD,EAAwB,CAAC;AACnCW,IAAAA,GAAG,EAAE,6BAD8B;AAEnCC,IAAAA,KAAK,EAAE,SAASH,2BAAT,GAAuC;AAC5C,UAAII,KAAK,GAAG,IAAZ;;AAEA,UAAI,KAAKV,eAAL,GAAuB,KAAKG,mBAAhC,EAAqD;AACnD,aAAKQ,cAAL,GAAsB,KAAtB;AACA,YAAIC,sBAAsB,GAAG,KAAKZ,eAAlC;AACA,aAAKD,kBAAL,CAAwBc,qBAAxB,CAA8C,KAAKZ,WAAnD,EAAgEa,IAAhE,CAAqE,UAAUC,MAAV,EAAkB;AACrF,cAAIA,MAAM,KAAK,KAAf,EAAsB;AACpBL,YAAAA,KAAK,CAACP,mBAAN,GAA4Ba,IAAI,CAACC,GAAL,CAASP,KAAK,CAACP,mBAAf,EAAoCS,sBAApC,CAA5B,CAFmF,CAEM;;AAE3F,cAAIF,KAAK,CAACC,cAAV,EAA0B;AACxBD,YAAAA,KAAK,CAACJ,2BAAN;AACD,WAFD,MAEO;AACLI,YAAAA,KAAK,CAACH,OAAN,CAAcW,YAAd;AACD;AACF,SATD;AAUD;AACF;AACD;;;;;;;AApBmC,GAAD,EA2BjC;AACDV,IAAAA,GAAG,EAAE,KADJ;AAEDC,IAAAA,KAAK,EAAE,SAASL,GAAT,CAAae,YAAb,EAA2BlB,WAA3B,EAAwC;AAC7C;AACA;AACA,UAAIkB,YAAY,IAAI,KAAKhB,mBAArB,IAA4CgB,YAAY,IAAI,KAAKnB,eAArE,EAAsF;AACtF,WAAKA,eAAL,GAAuBmB,YAAvB;AACA,WAAKR,cAAL,GAAsB,IAAtB;AACA,WAAKJ,OAAL,CAAaa,KAAb;AACA,WAAKnB,WAAL,GAAmBA,WAAnB;AACA,UAAI,KAAKF,kBAAL,CAAwBsB,yBAAxB,EAAJ,EAAyD;;AAEzD,WAAKf,2BAAL;AACD;AAbA,GA3BiC,CAAxB,CAAZ;;AA2CA,SAAOT,qBAAP;AACD,CArEwC,EAAzC;;AAuEA,SAASA,qBAAqB,IAAIyB,OAAlC","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Backoff from '../../utils/backoff';\n/**\n * MySegmentUpdateWorker class\n */\n\nvar MySegmentUpdateWorker = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {Object} mySegmentsStorage\n   * @param {Object} mySegmentsProducer\n   */\n  function MySegmentUpdateWorker(mySegmentsStorage, mySegmentsProducer) {\n    _classCallCheck(this, MySegmentUpdateWorker);\n\n    this.mySegmentsStorage = mySegmentsStorage;\n    this.mySegmentsProducer = mySegmentsProducer;\n    this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events\n\n    this.segmentList = undefined; // keeps the segmentList (if included in payload) from the queued event with maximum changeNumber\n\n    this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber\n\n    this.put = this.put.bind(this);\n    this.__handleMySegmentUpdateCall = this.__handleMySegmentUpdateCall.bind(this);\n    this.backoff = new Backoff(this.__handleMySegmentUpdateCall);\n  } // Private method\n  // Preconditions: this.mySegmentsProducer.isSynchronizingMySegments === false\n  // @TODO update this block similar to SplitUpdateWorker, once `/mySegments` endpoint provides the changeNumber\n\n\n  _createClass(MySegmentUpdateWorker, [{\n    key: \"__handleMySegmentUpdateCall\",\n    value: function __handleMySegmentUpdateCall() {\n      var _this = this;\n\n      if (this.maxChangeNumber > this.currentChangeNumber) {\n        this.handleNewEvent = false;\n        var currentMaxChangeNumber = this.maxChangeNumber;\n        this.mySegmentsProducer.synchronizeMySegments(this.segmentList).then(function (result) {\n          if (result !== false) // Unlike `Split\\SegmentUpdateWorker`, we cannot use `mySegmentsStorage.getChangeNumber` since `/mySegments` endpoint doesn't provide this value.\n            _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.\n\n          if (_this.handleNewEvent) {\n            _this.__handleMySegmentUpdateCall();\n          } else {\n            _this.backoff.scheduleCall();\n          }\n        });\n      }\n    }\n    /**\n     * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event\n     *\n     * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification\n     * @param {string[] | undefined} segmentList might be undefined\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(changeNumber, segmentList) {\n      // @TODO uncomment next line once `/mySegments` endpoint provides the changeNumber\n      // const currentChangeNumber = this.mySegmentsStorage.getChangeNumber();\n      if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber) return;\n      this.maxChangeNumber = changeNumber;\n      this.handleNewEvent = true;\n      this.backoff.reset();\n      this.segmentList = segmentList;\n      if (this.mySegmentsProducer.isSynchronizingMySegments()) return;\n\n      this.__handleMySegmentUpdateCall();\n    }\n  }]);\n\n  return MySegmentUpdateWorker;\n}();\n\nexport { MySegmentUpdateWorker as default };"]},"metadata":{},"sourceType":"module"}