{"ast":null,"code":"import React from 'react';\nimport { SplitFactory as SplitSdk } from './splitio'; // exported for testing purposes\n\nexport const __factories = new Map(); // idempotent operation\n\nexport function getSplitFactory(config) {\n  if (!__factories.has(config)) {\n    // SplitSDK is not an idempotent operation\n    const newFactory = SplitSdk(config);\n    newFactory.sharedClientInstances = new Set();\n    newFactory.config = config;\n\n    __factories.set(config, newFactory);\n  }\n\n  return __factories.get(config);\n} // idempotent operation\n\nexport function getSplitSharedClient(factory, key, trafficType) {\n  // factory.client is an idempotent operation\n  const client = factory.client(key, trafficType);\n\n  if (factory.sharedClientInstances) {\n    factory.sharedClientInstances.add(client);\n  }\n\n  return client;\n}\nexport function destroySplitFactory(factory) {\n  // call destroy of shared clients and main one\n  const destroyPromises = [];\n  factory.sharedClientInstances.forEach(client => destroyPromises.push(client.destroy()));\n  destroyPromises.push(factory.client().destroy()); // remove references to release allocated memory\n\n  factory.sharedClientInstances.clear();\n\n  __factories.delete(factory.config);\n\n  return Promise.all(destroyPromises);\n}\nexport function getIsReady(client) {\n  return client.__context.get(client.__context.constants.READY, true) ? true : false;\n}\nexport function getIsReadyFromCache(client) {\n  return client.__context.get(client.__context.constants.READY_FROM_CACHE, true) ? true : false;\n}\nexport function getHasTimedout(client) {\n  return client.__context.get(client.__context.constants.HAS_TIMEDOUT, true) ? true : false;\n}\nexport function getIsDestroyed(client) {\n  return client.__context.get(client.__context.constants.DESTROYED, true) ? true : false;\n}\nexport function getStatus(client) {\n  const isReady = client ? getIsReady(client) : false;\n  const hasTimedout = client ? getHasTimedout(client) : false;\n  return {\n    isReady,\n    isReadyFromCache: client ? getIsReadyFromCache(client) : false,\n    isTimedout: hasTimedout && !isReady,\n    hasTimedout,\n    isDestroyed: client ? getIsDestroyed(client) : false\n  };\n} // Other utils\n\n/**\n * Checks if React.useContext is available, and logs given message if not\n *\n * @param message\n * @returns boolean indicating if React.useContext is available\n */\n\nexport function checkHooks(message) {\n  if (!React.useContext) {\n    console.log(message);\n    return false;\n  } else {\n    return true;\n  }\n} // Input validation utils that will be replaced eventually\n\nexport function validateSplits(maybeSplits, listName = 'split names') {\n  if (Array.isArray(maybeSplits) && maybeSplits.length > 0) {\n    const validatedArray = []; // Remove invalid values\n\n    maybeSplits.forEach(maybeSplit => {\n      const splitName = validateSplit(maybeSplit);\n      if (splitName) validatedArray.push(splitName);\n    }); // Strip off duplicated values if we have valid split names then return\n\n    if (validatedArray.length) return uniq(validatedArray);\n  }\n\n  console.log(`[ERROR] ${listName} must be a non-empty array.`);\n  return false;\n}\nconst TRIMMABLE_SPACES_REGEX = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/;\n\nfunction validateSplit(maybeSplit, item = 'split name') {\n  // tslint:disable-next-line: triple-equals\n  if (maybeSplit == undefined) {\n    console.log(`[ERROR] you passed a null or undefined ${item}, ${item} must be a non-empty string.`);\n  } else if (!isString(maybeSplit)) {\n    console.log(`[ERROR] you passed an invalid ${item}, ${item} must be a non-empty string.`);\n  } else {\n    if (TRIMMABLE_SPACES_REGEX.test(maybeSplit)) {\n      console.log(`[WARN] ${item} \"${maybeSplit}\" has extra whitespace, trimming.`);\n      maybeSplit = maybeSplit.trim();\n    }\n\n    if (maybeSplit.length > 0) {\n      return maybeSplit;\n    } else {\n      console.log(`[ERROR] you passed an empty ${item}, ${item} must be a non-empty string.`);\n    }\n  }\n\n  return false;\n}\n/**\n * Removes duplicate items on an array of strings.\n */\n\n\nfunction uniq(arr) {\n  const seen = {};\n  return arr.filter(item => {\n    return Object.prototype.hasOwnProperty.call(seen, item) ? false : seen[item] = true;\n  });\n}\n/**\n * Checks if a given value is a string.\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string' || val instanceof String;\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/utils.js"],"names":["React","SplitFactory","SplitSdk","__factories","Map","getSplitFactory","config","has","newFactory","sharedClientInstances","Set","set","get","getSplitSharedClient","factory","key","trafficType","client","add","destroySplitFactory","destroyPromises","forEach","push","destroy","clear","delete","Promise","all","getIsReady","__context","constants","READY","getIsReadyFromCache","READY_FROM_CACHE","getHasTimedout","HAS_TIMEDOUT","getIsDestroyed","DESTROYED","getStatus","isReady","hasTimedout","isReadyFromCache","isTimedout","isDestroyed","checkHooks","message","useContext","console","log","validateSplits","maybeSplits","listName","Array","isArray","length","validatedArray","maybeSplit","splitName","validateSplit","uniq","TRIMMABLE_SPACES_REGEX","item","undefined","isString","test","trim","arr","seen","filter","Object","prototype","hasOwnProperty","call","val","String"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { SplitFactory as SplitSdk } from './splitio';\n// exported for testing purposes\nexport const __factories = new Map();\n// idempotent operation\nexport function getSplitFactory(config) {\n    if (!__factories.has(config)) {\n        // SplitSDK is not an idempotent operation\n        const newFactory = SplitSdk(config);\n        newFactory.sharedClientInstances = new Set();\n        newFactory.config = config;\n        __factories.set(config, newFactory);\n    }\n    return __factories.get(config);\n}\n// idempotent operation\nexport function getSplitSharedClient(factory, key, trafficType) {\n    // factory.client is an idempotent operation\n    const client = factory.client(key, trafficType);\n    if (factory.sharedClientInstances) {\n        factory.sharedClientInstances.add(client);\n    }\n    return client;\n}\nexport function destroySplitFactory(factory) {\n    // call destroy of shared clients and main one\n    const destroyPromises = [];\n    factory.sharedClientInstances.forEach((client) => destroyPromises.push(client.destroy()));\n    destroyPromises.push(factory.client().destroy());\n    // remove references to release allocated memory\n    factory.sharedClientInstances.clear();\n    __factories.delete(factory.config);\n    return Promise.all(destroyPromises);\n}\nexport function getIsReady(client) {\n    return client.__context.get(client.__context.constants.READY, true) ? true : false;\n}\nexport function getIsReadyFromCache(client) {\n    return client.__context.get(client.__context.constants.READY_FROM_CACHE, true) ? true : false;\n}\nexport function getHasTimedout(client) {\n    return client.__context.get(client.__context.constants.HAS_TIMEDOUT, true) ? true : false;\n}\nexport function getIsDestroyed(client) {\n    return client.__context.get(client.__context.constants.DESTROYED, true) ? true : false;\n}\nexport function getStatus(client) {\n    const isReady = client ? getIsReady(client) : false;\n    const hasTimedout = client ? getHasTimedout(client) : false;\n    return {\n        isReady,\n        isReadyFromCache: client ? getIsReadyFromCache(client) : false,\n        isTimedout: hasTimedout && !isReady,\n        hasTimedout,\n        isDestroyed: client ? getIsDestroyed(client) : false,\n    };\n}\n// Other utils\n/**\n * Checks if React.useContext is available, and logs given message if not\n *\n * @param message\n * @returns boolean indicating if React.useContext is available\n */\nexport function checkHooks(message) {\n    if (!React.useContext) {\n        console.log(message);\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n// Input validation utils that will be replaced eventually\nexport function validateSplits(maybeSplits, listName = 'split names') {\n    if (Array.isArray(maybeSplits) && maybeSplits.length > 0) {\n        const validatedArray = [];\n        // Remove invalid values\n        maybeSplits.forEach((maybeSplit) => {\n            const splitName = validateSplit(maybeSplit);\n            if (splitName)\n                validatedArray.push(splitName);\n        });\n        // Strip off duplicated values if we have valid split names then return\n        if (validatedArray.length)\n            return uniq(validatedArray);\n    }\n    console.log(`[ERROR] ${listName} must be a non-empty array.`);\n    return false;\n}\nconst TRIMMABLE_SPACES_REGEX = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/;\nfunction validateSplit(maybeSplit, item = 'split name') {\n    // tslint:disable-next-line: triple-equals\n    if (maybeSplit == undefined) {\n        console.log(`[ERROR] you passed a null or undefined ${item}, ${item} must be a non-empty string.`);\n    }\n    else if (!isString(maybeSplit)) {\n        console.log(`[ERROR] you passed an invalid ${item}, ${item} must be a non-empty string.`);\n    }\n    else {\n        if (TRIMMABLE_SPACES_REGEX.test(maybeSplit)) {\n            console.log(`[WARN] ${item} \"${maybeSplit}\" has extra whitespace, trimming.`);\n            maybeSplit = maybeSplit.trim();\n        }\n        if (maybeSplit.length > 0) {\n            return maybeSplit;\n        }\n        else {\n            console.log(`[ERROR] you passed an empty ${item}, ${item} must be a non-empty string.`);\n        }\n    }\n    return false;\n}\n/**\n * Removes duplicate items on an array of strings.\n */\nfunction uniq(arr) {\n    const seen = {};\n    return arr.filter((item) => {\n        return Object.prototype.hasOwnProperty.call(seen, item) ? false : seen[item] = true;\n    });\n}\n/**\n * Checks if a given value is a string.\n */\nfunction isString(val) {\n    return typeof val === 'string' || val instanceof String;\n}\n"]},"metadata":{},"sourceType":"module"}