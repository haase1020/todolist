{"ast":null,"code":"import { errorParser, messageParser } from './NotificationParser';\nimport notificationKeeperFactory from './NotificationKeeper';\nimport { SSE_ERROR, SPLIT_UPDATE, SEGMENT_UPDATE, MY_SEGMENTS_UPDATE, SPLIT_KILL, OCCUPANCY, CONTROL } from '../constants';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-sync:sse-handler');\n/**\n * Factory for SSEHandler\n *\n * @param {Object} pushEmitter emitter for emitting events related to feedback-loop & update queues\n */\n\nexport default function SSEHandlerFactory(pushEmitter) {\n  var notificationKeeper = notificationKeeperFactory(pushEmitter);\n  return {\n    handleOpen: function handleOpen() {\n      notificationKeeper.handleOpen();\n    },\n\n    /* HTTP & Network errors */\n    handleError: function handleError(error) {\n      var errorWithParsedData = error;\n\n      try {\n        errorWithParsedData = errorParser(error);\n      } catch (err) {\n        log.warn(\"Error parsing SSE error notification: \".concat(err));\n      }\n\n      pushEmitter.emit(SSE_ERROR, errorWithParsedData);\n    },\n\n    /* NotificationProcessor */\n    handleMessage: function handleMessage(message) {\n      var messageWithParsedData;\n\n      try {\n        messageWithParsedData = messageParser(message);\n      } catch (err) {\n        log.warn(\"Error parsing new SSE message notification: \".concat(err));\n        return;\n      }\n\n      var _messageWithParsedDat = messageWithParsedData,\n          parsedData = _messageWithParsedDat.parsedData,\n          data = _messageWithParsedDat.data,\n          channel = _messageWithParsedDat.channel,\n          timestamp = _messageWithParsedDat.timestamp;\n      log.debug(\"New SSE message received, with data: \".concat(data, \".\")); // we only handle update events if streaming is up.\n\n      if (!notificationKeeper.isStreamingUp() && parsedData.type !== OCCUPANCY && parsedData.type !== CONTROL) return;\n\n      switch (parsedData.type) {\n        /* update events */\n        case SPLIT_UPDATE:\n          pushEmitter.emit(SPLIT_UPDATE, parsedData.changeNumber);\n          break;\n\n        case SEGMENT_UPDATE:\n          pushEmitter.emit(SEGMENT_UPDATE, parsedData.changeNumber, parsedData.segmentName);\n          break;\n\n        case MY_SEGMENTS_UPDATE:\n          pushEmitter.emit(MY_SEGMENTS_UPDATE, parsedData, channel);\n          break;\n\n        case SPLIT_KILL:\n          pushEmitter.emit(SPLIT_KILL, parsedData.changeNumber, parsedData.splitName, parsedData.defaultTreatment);\n          break;\n\n        /* occupancy & control events, handled by NotificationManagerKeeper */\n\n        case OCCUPANCY:\n          notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);\n          break;\n\n        case CONTROL:\n          notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/SSEHandler/index.js"],"names":["errorParser","messageParser","notificationKeeperFactory","SSE_ERROR","SPLIT_UPDATE","SEGMENT_UPDATE","MY_SEGMENTS_UPDATE","SPLIT_KILL","OCCUPANCY","CONTROL","logFactory","log","SSEHandlerFactory","pushEmitter","notificationKeeper","handleOpen","handleError","error","errorWithParsedData","err","warn","concat","emit","handleMessage","message","messageWithParsedData","_messageWithParsedDat","parsedData","data","channel","timestamp","debug","isStreamingUp","type","changeNumber","segmentName","splitName","defaultTreatment","handleOccupancyEvent","metrics","publishers","handleControlEvent","controlType"],"mappings":"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","sourcesContent":["import { errorParser, messageParser } from './NotificationParser';\nimport notificationKeeperFactory from './NotificationKeeper';\nimport { SSE_ERROR, SPLIT_UPDATE, SEGMENT_UPDATE, MY_SEGMENTS_UPDATE, SPLIT_KILL, OCCUPANCY, CONTROL } from '../constants';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-sync:sse-handler');\n/**\n * Factory for SSEHandler\n *\n * @param {Object} pushEmitter emitter for emitting events related to feedback-loop & update queues\n */\n\nexport default function SSEHandlerFactory(pushEmitter) {\n  var notificationKeeper = notificationKeeperFactory(pushEmitter);\n  return {\n    handleOpen: function handleOpen() {\n      notificationKeeper.handleOpen();\n    },\n\n    /* HTTP & Network errors */\n    handleError: function handleError(error) {\n      var errorWithParsedData = error;\n\n      try {\n        errorWithParsedData = errorParser(error);\n      } catch (err) {\n        log.warn(\"Error parsing SSE error notification: \".concat(err));\n      }\n\n      pushEmitter.emit(SSE_ERROR, errorWithParsedData);\n    },\n\n    /* NotificationProcessor */\n    handleMessage: function handleMessage(message) {\n      var messageWithParsedData;\n\n      try {\n        messageWithParsedData = messageParser(message);\n      } catch (err) {\n        log.warn(\"Error parsing new SSE message notification: \".concat(err));\n        return;\n      }\n\n      var _messageWithParsedDat = messageWithParsedData,\n          parsedData = _messageWithParsedDat.parsedData,\n          data = _messageWithParsedDat.data,\n          channel = _messageWithParsedDat.channel,\n          timestamp = _messageWithParsedDat.timestamp;\n      log.debug(\"New SSE message received, with data: \".concat(data, \".\")); // we only handle update events if streaming is up.\n\n      if (!notificationKeeper.isStreamingUp() && parsedData.type !== OCCUPANCY && parsedData.type !== CONTROL) return;\n\n      switch (parsedData.type) {\n        /* update events */\n        case SPLIT_UPDATE:\n          pushEmitter.emit(SPLIT_UPDATE, parsedData.changeNumber);\n          break;\n\n        case SEGMENT_UPDATE:\n          pushEmitter.emit(SEGMENT_UPDATE, parsedData.changeNumber, parsedData.segmentName);\n          break;\n\n        case MY_SEGMENTS_UPDATE:\n          pushEmitter.emit(MY_SEGMENTS_UPDATE, parsedData, channel);\n          break;\n\n        case SPLIT_KILL:\n          pushEmitter.emit(SPLIT_KILL, parsedData.changeNumber, parsedData.splitName, parsedData.defaultTreatment);\n          break;\n\n        /* occupancy & control events, handled by NotificationManagerKeeper */\n\n        case OCCUPANCY:\n          notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);\n          break;\n\n        case CONTROL:\n          notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);\n          break;\n\n        default:\n          break;\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}