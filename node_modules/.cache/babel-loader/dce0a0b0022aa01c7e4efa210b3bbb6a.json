{"ast":null,"code":"/**\n * wraps a given promise in a new one with a default onRejected function,\n * that handles the promise rejection if not other onRejected handler is provided.\n *\n * Caveats: there are some cases where the `defaultOnRejected` handler is not invoked\n * and the promise rejection must be handled by the user (same as the Promise spec):\n *  - using async/await syntax\n *  - setting an `onFinally` handler as the first handler (e.g. `promiseWrapper(Promise.reject()).finally(...)`)\n *  - setting more than one handler with at least one of them being an onRejected handler\n *\n * @param customPromise promise to wrap\n * @param defaultOnRejected default onRejected function\n * @returns a promise that doesn't need to be handled for rejection (except when using async/await syntax) and\n * with a method named `hasOnFulfilled` that returns true if the promise has attached an onFulfilled handler.\n */\nexport default function promiseWrapper(customPromise, defaultOnRejected) {\n  var hasOnFulfilled = false;\n  var hasOnRejected = false;\n\n  function chain(promise) {\n    var newPromise = new Promise(function (res, rej) {\n      return promise.then(res, function (value) {\n        if (hasOnRejected) {\n          rej(value);\n        } else {\n          defaultOnRejected(value);\n        }\n      });\n    });\n    var originalThen = newPromise.then;\n\n    newPromise.then = function (onfulfilled, onrejected) {\n      var result = originalThen.call(newPromise, onfulfilled, onrejected);\n      if (typeof onfulfilled === 'function') hasOnFulfilled = true;\n\n      if (typeof onrejected === 'function') {\n        hasOnRejected = true;\n        return result;\n      } else {\n        return chain(result);\n      }\n    };\n\n    return newPromise;\n  }\n\n  var result = chain(customPromise);\n\n  result.hasOnFulfilled = function () {\n    return hasOnFulfilled;\n  };\n\n  return result;\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/utils/promise/wrapper.js"],"names":["promiseWrapper","customPromise","defaultOnRejected","hasOnFulfilled","hasOnRejected","chain","promise","newPromise","Promise","res","rej","then","value","originalThen","onfulfilled","onrejected","result","call"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,eAAe,SAASA,cAAT,CAAwBC,aAAxB,EAAuCC,iBAAvC,EAA0D;AACvE,MAAIC,cAAc,GAAG,KAArB;AACA,MAAIC,aAAa,GAAG,KAApB;;AAEA,WAASC,KAAT,CAAeC,OAAf,EAAwB;AACtB,QAAIC,UAAU,GAAG,IAAIC,OAAJ,CAAY,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AAC/C,aAAOJ,OAAO,CAACK,IAAR,CAAaF,GAAb,EAAkB,UAAUG,KAAV,EAAiB;AACxC,YAAIR,aAAJ,EAAmB;AACjBM,UAAAA,GAAG,CAACE,KAAD,CAAH;AACD,SAFD,MAEO;AACLV,UAAAA,iBAAiB,CAACU,KAAD,CAAjB;AACD;AACF,OANM,CAAP;AAOD,KARgB,CAAjB;AASA,QAAIC,YAAY,GAAGN,UAAU,CAACI,IAA9B;;AAEAJ,IAAAA,UAAU,CAACI,IAAX,GAAkB,UAAUG,WAAV,EAAuBC,UAAvB,EAAmC;AACnD,UAAIC,MAAM,GAAGH,YAAY,CAACI,IAAb,CAAkBV,UAAlB,EAA8BO,WAA9B,EAA2CC,UAA3C,CAAb;AACA,UAAI,OAAOD,WAAP,KAAuB,UAA3B,EAAuCX,cAAc,GAAG,IAAjB;;AAEvC,UAAI,OAAOY,UAAP,KAAsB,UAA1B,EAAsC;AACpCX,QAAAA,aAAa,GAAG,IAAhB;AACA,eAAOY,MAAP;AACD,OAHD,MAGO;AACL,eAAOX,KAAK,CAACW,MAAD,CAAZ;AACD;AACF,KAVD;;AAYA,WAAOT,UAAP;AACD;;AAED,MAAIS,MAAM,GAAGX,KAAK,CAACJ,aAAD,CAAlB;;AAEAe,EAAAA,MAAM,CAACb,cAAP,GAAwB,YAAY;AAClC,WAAOA,cAAP;AACD,GAFD;;AAIA,SAAOa,MAAP;AACD","sourcesContent":["/**\n * wraps a given promise in a new one with a default onRejected function,\n * that handles the promise rejection if not other onRejected handler is provided.\n *\n * Caveats: there are some cases where the `defaultOnRejected` handler is not invoked\n * and the promise rejection must be handled by the user (same as the Promise spec):\n *  - using async/await syntax\n *  - setting an `onFinally` handler as the first handler (e.g. `promiseWrapper(Promise.reject()).finally(...)`)\n *  - setting more than one handler with at least one of them being an onRejected handler\n *\n * @param customPromise promise to wrap\n * @param defaultOnRejected default onRejected function\n * @returns a promise that doesn't need to be handled for rejection (except when using async/await syntax) and\n * with a method named `hasOnFulfilled` that returns true if the promise has attached an onFulfilled handler.\n */\nexport default function promiseWrapper(customPromise, defaultOnRejected) {\n  var hasOnFulfilled = false;\n  var hasOnRejected = false;\n\n  function chain(promise) {\n    var newPromise = new Promise(function (res, rej) {\n      return promise.then(res, function (value) {\n        if (hasOnRejected) {\n          rej(value);\n        } else {\n          defaultOnRejected(value);\n        }\n      });\n    });\n    var originalThen = newPromise.then;\n\n    newPromise.then = function (onfulfilled, onrejected) {\n      var result = originalThen.call(newPromise, onfulfilled, onrejected);\n      if (typeof onfulfilled === 'function') hasOnFulfilled = true;\n\n      if (typeof onrejected === 'function') {\n        hasOnRejected = true;\n        return result;\n      } else {\n        return chain(result);\n      }\n    };\n\n    return newPromise;\n  }\n\n  var result = chain(customPromise);\n\n  result.hasOnFulfilled = function () {\n    return hasOnFulfilled;\n  };\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}