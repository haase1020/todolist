{"ast":null,"code":"import EventEmitter from 'events';\nimport objectAssign from 'object-assign';\nimport authenticate from '../AuthClient';\nimport { checkPushRequirements } from './pushRequirements';\nimport SegmentUpdateWorker from '../SegmentUpdateWorker';\nimport SplitUpdateWorker from '../SplitUpdateWorker';\nimport SSEClient from '../SSEClient';\nimport SSEHandlerFactory from '../SSEHandler';\nimport Backoff from '../../utils/backoff';\nimport { hashUserKey } from '../../utils/jwt/hashUserKey';\nimport logFactory from '../../utils/logger';\nimport { SECONDS_BEFORE_EXPIRATION, PUSH_DISCONNECT, PUSH_DISABLED, SSE_ERROR, SPLIT_KILL, SPLIT_UPDATE, SEGMENT_UPDATE, MY_SEGMENTS_UPDATE } from '../constants';\nvar log = logFactory('splitio-sync:push-manager');\n/**\n * Factory of the push mode manager.\n *\n * @param {Object} context context of main client.\n * @param {Object | undefined} clientContexts map of user keys to client contexts to handle sync of MySegments. undefined for node.\n */\n\nexport default function PushManagerFactory(context, clientContexts\n/* undefined for node */\n) {\n  // No return a PushManager if PUSH mode is not supported.\n  if (!checkPushRequirements(log)) return;\n  var pushEmitter = new EventEmitter();\n\n  var _context$get = context.get(context.constants.READINESS),\n      splitsEventEmitter = _context$get.splits;\n\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n  var sseClient = SSEClient.getInstance(settings);\n  var sseHandler = SSEHandlerFactory(pushEmitter);\n  sseClient.setEventHandler(sseHandler); // map of hashes to user keys, to dispatch MY_SEGMENTS_UPDATE events to the corresponding MySegmentsUpdateWorker\n\n  var userKeyHashes = {}; // list of workers, used to stop them all together when push is disconnected\n\n  var workers = []; // variable used on browser to reconnect only when a new client was added, saving some authentication and sse connections.\n\n  var connectForNewClient = false; // flag that indicates if `disconnectPush` was called, either by the SyncManager (when the client is destroyed) or by a STREAMING_DISABLED control notification\n\n  var disconnected;\n  /** PushManager functions related to initialization */\n\n  var reauthBackoff = new Backoff(connectPush, settings.scheduler.authRetryBackoffBase);\n  var sseReconnectBackoff = new Backoff(sseClient.reopen, settings.scheduler.streamingReconnectBackoffBase);\n  var timeoutId = 0;\n\n  function scheduleTokenRefresh(issuedAt, expirationTime) {\n    // clear scheduled token refresh if exists (needed when resuming PUSH)\n    if (timeoutId) clearTimeout(timeoutId); // Set token refresh 10 minutes before expirationTime\n\n    var delayInSeconds = expirationTime - issuedAt - SECONDS_BEFORE_EXPIRATION;\n    log.info(\"Refreshing streaming token in \".concat(delayInSeconds, \" seconds.\"));\n    timeoutId = setTimeout(connectPush, delayInSeconds * 1000);\n  }\n\n  function connectPush() {\n    disconnected = false;\n    log.info('Connecting to push streaming.');\n    var userKeys = clientContexts ? Object.keys(clientContexts) : undefined;\n    authenticate(settings, userKeys).then(function (authData) {\n      if (disconnected) return; // restart backoff retry counter for auth and SSE connections, due to HTTP/network errors\n\n      reauthBackoff.reset();\n      sseReconnectBackoff.reset(); // reset backoff in case SSE conexion has opened after a HTTP or network error.\n      // emit PUSH_DISCONNECT if org is not whitelisted\n\n      if (!authData.pushEnabled) {\n        log.info('Streaming is not available. Switching to polling mode.');\n        pushEmitter.emit(PUSH_DISCONNECT); // there is no need to close sseClient (it is not open on this scenario)\n\n        return;\n      } // don't open SSE connection if a new shared client was added, since it means that a new authentication is taking place\n\n\n      if (userKeys && userKeys.length < Object.keys(clientContexts).length) return; // Connect to SSE and schedule refresh token\n\n      var decodedToken = authData.decodedToken;\n      sseClient.open(authData);\n      scheduleTokenRefresh(decodedToken.iat, decodedToken.exp);\n    }).catch(function (error) {\n      if (disconnected) return;\n      sseClient.close(); // no harm if already closed\n\n      pushEmitter.emit(PUSH_DISCONNECT); // no harm if `PUSH_DISCONNECT` was already notified\n\n      var errorMessage = \"Failed to authenticate for streaming. Error: \\\"\".concat(error.message, \"\\\".\"); // Handle 4XX HTTP errors: 401 (invalid API Key) or 400 (using incorrect API Key, i.e., client-side API Key on server-side)\n\n      if (error.statusCode >= 400 && error.statusCode < 500) {\n        log.error(errorMessage);\n        return;\n      } // Handle other HTTP and network errors\n\n\n      var delayInMillis = reauthBackoff.scheduleCall();\n      log.error(\"\".concat(errorMessage, \". Attempting to reauthenticate in \").concat(delayInMillis / 1000, \" seconds.\"));\n    });\n  } // close SSE connection and cancel scheduled tasks\n\n\n  function disconnectPush() {\n    disconnected = true;\n    log.info('Disconnecting from push streaming.');\n    sseClient.close();\n    if (timeoutId) clearTimeout(timeoutId);\n    reauthBackoff.reset();\n    sseReconnectBackoff.reset();\n  } // cancel scheduled fetch retries of Split, Segment, and MySegment Update Workers\n\n\n  function stopWorkers() {\n    workers.forEach(function (worker) {\n      return worker.backoff.reset();\n    });\n  }\n\n  pushEmitter.on(PUSH_DISCONNECT, stopWorkers);\n  /** Fallbacking due to STREAMING_DISABLED control event */\n\n  pushEmitter.on(PUSH_DISABLED, function () {\n    disconnectPush();\n    pushEmitter.emit(PUSH_DISCONNECT); // no harm if polling already\n  });\n  /** Fallbacking due to SSE errors */\n\n  pushEmitter.on(SSE_ERROR, function (error) {\n    // HTTP or network error in SSE connection\n    // SSE connection is closed to avoid repeated errors due to retries\n    sseClient.close(); // retries are handled via backoff algorithm\n\n    var delayInMillis;\n\n    if (error.parsedData && (error.parsedData.statusCode === 400 || error.parsedData.statusCode === 401)) {\n      delayInMillis = reauthBackoff.scheduleCall(); // reauthenticate in case of token invalid or expired (when somehow refresh token was not properly executed)\n    } else {\n      delayInMillis = sseReconnectBackoff.scheduleCall(); // reconnect SSE for any other network or HTTP error\n    }\n\n    var errorMessage = error.parsedData && error.parsedData.message;\n    log.error(\"Fail to connect to streaming\".concat(errorMessage ? \", with error message: \\\"\".concat(errorMessage, \"\\\"\") : '', \". Attempting to reconnect in \").concat(delayInMillis / 1000, \" seconds.\"));\n    pushEmitter.emit(PUSH_DISCONNECT); // no harm if polling already\n  });\n  /** Functions related to synchronization (Queues and Workers in the spec) */\n\n  var producer = context.get(context.constants.PRODUCER);\n  var splitUpdateWorker = new SplitUpdateWorker(storage.splits, producer, splitsEventEmitter);\n  workers.push(splitUpdateWorker);\n  pushEmitter.on(SPLIT_KILL, splitUpdateWorker.killSplit);\n  pushEmitter.on(SPLIT_UPDATE, splitUpdateWorker.put);\n\n  if (clientContexts) {\n    // browser\n    pushEmitter.on(MY_SEGMENTS_UPDATE, function handleMySegmentsUpdate(parsedData, channel) {\n      var userKeyHash = channel.split('_')[2];\n      var userKey = userKeyHashes[userKeyHash];\n\n      if (userKey && clientContexts[userKey]) {\n        // check context since it can be undefined if client has been destroyed\n        var mySegmentSync = clientContexts[userKey].get(context.constants.MY_SEGMENTS_CHANGE_WORKER, true);\n        mySegmentSync && mySegmentSync.put(parsedData.changeNumber, parsedData.includesPayload ? parsedData.segmentList ? parsedData.segmentList : [] : undefined);\n      }\n    });\n  } else {\n    // node\n    var segmentUpdateWorker = new SegmentUpdateWorker(storage.segments, producer);\n    workers.push(segmentUpdateWorker);\n    pushEmitter.on(SEGMENT_UPDATE, segmentUpdateWorker.put);\n  }\n\n  return objectAssign( // Expose Event Emitter functionality and Event constants\n  Object.create(pushEmitter), {\n    // Expose functionality for starting and stoping push mode:\n    stop: function stop() {\n      disconnectPush();\n      stopWorkers(); // if we call `stopWorkers` inside `disconnectPush`, it would be called twice on a PUSH_DISABLED event, which anyway is not harmful.\n    },\n    // used in node\n    start: connectPush,\n    // used in browser\n    startNewClient: function startNewClient(userKey, context) {\n      var hash = hashUserKey(userKey);\n      var storage = context.get(context.constants.STORAGE);\n      var producer = context.get(context.constants.PRODUCER);\n\n      if (!userKeyHashes[hash]) {\n        userKeyHashes[hash] = userKey;\n        connectForNewClient = true; // we must reconnect on start, to listen the channel for the new user key\n      }\n\n      var mySegmentSync = new SegmentUpdateWorker(storage.segments, producer);\n      workers.push(mySegmentSync);\n      context.put(context.constants.MY_SEGMENTS_CHANGE_WORKER, mySegmentSync); // Reconnects in case of a new client.\n      // Run in next event-loop cycle to save authentication calls\n      // in case the user is creating several clients in the current cycle.\n\n      setTimeout(function checkForReconnect() {\n        if (connectForNewClient) {\n          connectForNewClient = false;\n          connectPush();\n        }\n      }, 0);\n    },\n    removeClient: function removeClient(userKey) {\n      var hash = hashUserKey(userKey);\n      delete userKeyHashes[hash];\n    }\n  });\n}","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/sync/PushManager/index.js"],"names":["EventEmitter","objectAssign","authenticate","checkPushRequirements","SegmentUpdateWorker","SplitUpdateWorker","SSEClient","SSEHandlerFactory","Backoff","hashUserKey","logFactory","SECONDS_BEFORE_EXPIRATION","PUSH_DISCONNECT","PUSH_DISABLED","SSE_ERROR","SPLIT_KILL","SPLIT_UPDATE","SEGMENT_UPDATE","MY_SEGMENTS_UPDATE","log","PushManagerFactory","context","clientContexts","pushEmitter","_context$get","get","constants","READINESS","splitsEventEmitter","splits","settings","SETTINGS","storage","STORAGE","sseClient","getInstance","sseHandler","setEventHandler","userKeyHashes","workers","connectForNewClient","disconnected","reauthBackoff","connectPush","scheduler","authRetryBackoffBase","sseReconnectBackoff","reopen","streamingReconnectBackoffBase","timeoutId","scheduleTokenRefresh","issuedAt","expirationTime","clearTimeout","delayInSeconds","info","concat","setTimeout","userKeys","Object","keys","undefined","then","authData","reset","pushEnabled","emit","length","decodedToken","open","iat","exp","catch","error","close","errorMessage","message","statusCode","delayInMillis","scheduleCall","disconnectPush","stopWorkers","forEach","worker","backoff","on","parsedData","producer","PRODUCER","splitUpdateWorker","push","killSplit","put","handleMySegmentsUpdate","channel","userKeyHash","split","userKey","mySegmentSync","MY_SEGMENTS_CHANGE_WORKER","changeNumber","includesPayload","segmentList","segmentUpdateWorker","segments","create","stop","start","startNewClient","hash","checkForReconnect","removeClient"],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\nimport objectAssign from 'object-assign';\nimport authenticate from '../AuthClient';\nimport { checkPushRequirements } from './pushRequirements';\nimport SegmentUpdateWorker from '../SegmentUpdateWorker';\nimport SplitUpdateWorker from '../SplitUpdateWorker';\nimport SSEClient from '../SSEClient';\nimport SSEHandlerFactory from '../SSEHandler';\nimport Backoff from '../../utils/backoff';\nimport { hashUserKey } from '../../utils/jwt/hashUserKey';\nimport logFactory from '../../utils/logger';\nimport { SECONDS_BEFORE_EXPIRATION, PUSH_DISCONNECT, PUSH_DISABLED, SSE_ERROR, SPLIT_KILL, SPLIT_UPDATE, SEGMENT_UPDATE, MY_SEGMENTS_UPDATE } from '../constants';\nvar log = logFactory('splitio-sync:push-manager');\n/**\n * Factory of the push mode manager.\n *\n * @param {Object} context context of main client.\n * @param {Object | undefined} clientContexts map of user keys to client contexts to handle sync of MySegments. undefined for node.\n */\n\nexport default function PushManagerFactory(context, clientContexts\n/* undefined for node */\n) {\n  // No return a PushManager if PUSH mode is not supported.\n  if (!checkPushRequirements(log)) return;\n  var pushEmitter = new EventEmitter();\n\n  var _context$get = context.get(context.constants.READINESS),\n      splitsEventEmitter = _context$get.splits;\n\n  var settings = context.get(context.constants.SETTINGS);\n  var storage = context.get(context.constants.STORAGE);\n  var sseClient = SSEClient.getInstance(settings);\n  var sseHandler = SSEHandlerFactory(pushEmitter);\n  sseClient.setEventHandler(sseHandler); // map of hashes to user keys, to dispatch MY_SEGMENTS_UPDATE events to the corresponding MySegmentsUpdateWorker\n\n  var userKeyHashes = {}; // list of workers, used to stop them all together when push is disconnected\n\n  var workers = []; // variable used on browser to reconnect only when a new client was added, saving some authentication and sse connections.\n\n  var connectForNewClient = false; // flag that indicates if `disconnectPush` was called, either by the SyncManager (when the client is destroyed) or by a STREAMING_DISABLED control notification\n\n  var disconnected;\n  /** PushManager functions related to initialization */\n\n  var reauthBackoff = new Backoff(connectPush, settings.scheduler.authRetryBackoffBase);\n  var sseReconnectBackoff = new Backoff(sseClient.reopen, settings.scheduler.streamingReconnectBackoffBase);\n  var timeoutId = 0;\n\n  function scheduleTokenRefresh(issuedAt, expirationTime) {\n    // clear scheduled token refresh if exists (needed when resuming PUSH)\n    if (timeoutId) clearTimeout(timeoutId); // Set token refresh 10 minutes before expirationTime\n\n    var delayInSeconds = expirationTime - issuedAt - SECONDS_BEFORE_EXPIRATION;\n    log.info(\"Refreshing streaming token in \".concat(delayInSeconds, \" seconds.\"));\n    timeoutId = setTimeout(connectPush, delayInSeconds * 1000);\n  }\n\n  function connectPush() {\n    disconnected = false;\n    log.info('Connecting to push streaming.');\n    var userKeys = clientContexts ? Object.keys(clientContexts) : undefined;\n    authenticate(settings, userKeys).then(function (authData) {\n      if (disconnected) return; // restart backoff retry counter for auth and SSE connections, due to HTTP/network errors\n\n      reauthBackoff.reset();\n      sseReconnectBackoff.reset(); // reset backoff in case SSE conexion has opened after a HTTP or network error.\n      // emit PUSH_DISCONNECT if org is not whitelisted\n\n      if (!authData.pushEnabled) {\n        log.info('Streaming is not available. Switching to polling mode.');\n        pushEmitter.emit(PUSH_DISCONNECT); // there is no need to close sseClient (it is not open on this scenario)\n\n        return;\n      } // don't open SSE connection if a new shared client was added, since it means that a new authentication is taking place\n\n\n      if (userKeys && userKeys.length < Object.keys(clientContexts).length) return; // Connect to SSE and schedule refresh token\n\n      var decodedToken = authData.decodedToken;\n      sseClient.open(authData);\n      scheduleTokenRefresh(decodedToken.iat, decodedToken.exp);\n    }).catch(function (error) {\n      if (disconnected) return;\n      sseClient.close(); // no harm if already closed\n\n      pushEmitter.emit(PUSH_DISCONNECT); // no harm if `PUSH_DISCONNECT` was already notified\n\n      var errorMessage = \"Failed to authenticate for streaming. Error: \\\"\".concat(error.message, \"\\\".\"); // Handle 4XX HTTP errors: 401 (invalid API Key) or 400 (using incorrect API Key, i.e., client-side API Key on server-side)\n\n      if (error.statusCode >= 400 && error.statusCode < 500) {\n        log.error(errorMessage);\n        return;\n      } // Handle other HTTP and network errors\n\n\n      var delayInMillis = reauthBackoff.scheduleCall();\n      log.error(\"\".concat(errorMessage, \". Attempting to reauthenticate in \").concat(delayInMillis / 1000, \" seconds.\"));\n    });\n  } // close SSE connection and cancel scheduled tasks\n\n\n  function disconnectPush() {\n    disconnected = true;\n    log.info('Disconnecting from push streaming.');\n    sseClient.close();\n    if (timeoutId) clearTimeout(timeoutId);\n    reauthBackoff.reset();\n    sseReconnectBackoff.reset();\n  } // cancel scheduled fetch retries of Split, Segment, and MySegment Update Workers\n\n\n  function stopWorkers() {\n    workers.forEach(function (worker) {\n      return worker.backoff.reset();\n    });\n  }\n\n  pushEmitter.on(PUSH_DISCONNECT, stopWorkers);\n  /** Fallbacking due to STREAMING_DISABLED control event */\n\n  pushEmitter.on(PUSH_DISABLED, function () {\n    disconnectPush();\n    pushEmitter.emit(PUSH_DISCONNECT); // no harm if polling already\n  });\n  /** Fallbacking due to SSE errors */\n\n  pushEmitter.on(SSE_ERROR, function (error) {\n    // HTTP or network error in SSE connection\n    // SSE connection is closed to avoid repeated errors due to retries\n    sseClient.close(); // retries are handled via backoff algorithm\n\n    var delayInMillis;\n\n    if (error.parsedData && (error.parsedData.statusCode === 400 || error.parsedData.statusCode === 401)) {\n      delayInMillis = reauthBackoff.scheduleCall(); // reauthenticate in case of token invalid or expired (when somehow refresh token was not properly executed)\n    } else {\n      delayInMillis = sseReconnectBackoff.scheduleCall(); // reconnect SSE for any other network or HTTP error\n    }\n\n    var errorMessage = error.parsedData && error.parsedData.message;\n    log.error(\"Fail to connect to streaming\".concat(errorMessage ? \", with error message: \\\"\".concat(errorMessage, \"\\\"\") : '', \". Attempting to reconnect in \").concat(delayInMillis / 1000, \" seconds.\"));\n    pushEmitter.emit(PUSH_DISCONNECT); // no harm if polling already\n  });\n  /** Functions related to synchronization (Queues and Workers in the spec) */\n\n  var producer = context.get(context.constants.PRODUCER);\n  var splitUpdateWorker = new SplitUpdateWorker(storage.splits, producer, splitsEventEmitter);\n  workers.push(splitUpdateWorker);\n  pushEmitter.on(SPLIT_KILL, splitUpdateWorker.killSplit);\n  pushEmitter.on(SPLIT_UPDATE, splitUpdateWorker.put);\n\n  if (clientContexts) {\n    // browser\n    pushEmitter.on(MY_SEGMENTS_UPDATE, function handleMySegmentsUpdate(parsedData, channel) {\n      var userKeyHash = channel.split('_')[2];\n      var userKey = userKeyHashes[userKeyHash];\n\n      if (userKey && clientContexts[userKey]) {\n        // check context since it can be undefined if client has been destroyed\n        var mySegmentSync = clientContexts[userKey].get(context.constants.MY_SEGMENTS_CHANGE_WORKER, true);\n        mySegmentSync && mySegmentSync.put(parsedData.changeNumber, parsedData.includesPayload ? parsedData.segmentList ? parsedData.segmentList : [] : undefined);\n      }\n    });\n  } else {\n    // node\n    var segmentUpdateWorker = new SegmentUpdateWorker(storage.segments, producer);\n    workers.push(segmentUpdateWorker);\n    pushEmitter.on(SEGMENT_UPDATE, segmentUpdateWorker.put);\n  }\n\n  return objectAssign( // Expose Event Emitter functionality and Event constants\n  Object.create(pushEmitter), {\n    // Expose functionality for starting and stoping push mode:\n    stop: function stop() {\n      disconnectPush();\n      stopWorkers(); // if we call `stopWorkers` inside `disconnectPush`, it would be called twice on a PUSH_DISABLED event, which anyway is not harmful.\n    },\n    // used in node\n    start: connectPush,\n    // used in browser\n    startNewClient: function startNewClient(userKey, context) {\n      var hash = hashUserKey(userKey);\n      var storage = context.get(context.constants.STORAGE);\n      var producer = context.get(context.constants.PRODUCER);\n\n      if (!userKeyHashes[hash]) {\n        userKeyHashes[hash] = userKey;\n        connectForNewClient = true; // we must reconnect on start, to listen the channel for the new user key\n      }\n\n      var mySegmentSync = new SegmentUpdateWorker(storage.segments, producer);\n      workers.push(mySegmentSync);\n      context.put(context.constants.MY_SEGMENTS_CHANGE_WORKER, mySegmentSync); // Reconnects in case of a new client.\n      // Run in next event-loop cycle to save authentication calls\n      // in case the user is creating several clients in the current cycle.\n\n      setTimeout(function checkForReconnect() {\n        if (connectForNewClient) {\n          connectForNewClient = false;\n          connectPush();\n        }\n      }, 0);\n    },\n    removeClient: function removeClient(userKey) {\n      var hash = hashUserKey(userKey);\n      delete userKeyHashes[hash];\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}