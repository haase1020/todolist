{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { numberIsFinite, toNumber, numberIsNaN } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\nimport killLocally from './killLocally';\n\nvar SplitCacheLocalStorage = /*#__PURE__*/function () {\n  /**\n   * @param {Object} keys\n   * @param {number} expirationTimestamp\n   * @param {Object} splitFiltersValidation\n   */\n  function SplitCacheLocalStorage(keys, expirationTimestamp, splitFiltersValidation) {\n    _classCallCheck(this, SplitCacheLocalStorage);\n\n    this.keys = keys;\n    this.splitFiltersValidation = splitFiltersValidation;\n\n    this.__checkExpiration(expirationTimestamp);\n\n    this.__checkFilterQuery();\n  }\n\n  _createClass(SplitCacheLocalStorage, [{\n    key: \"decrementCount\",\n    value: function decrementCount(key) {\n      var count = toNumber(localStorage.getItem(key)) - 1;\n      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);\n    }\n  }, {\n    key: \"decrementCounts\",\n    value: function decrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            this.decrementCount(ttKey);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n            this.decrementCount(segmentsCountKey);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"incrementCounts\",\n    value: function incrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n            localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      try {\n        var splitKey = this.keys.buildSplitKey(splitName);\n        var splitFromLocalStorage = localStorage.getItem(splitKey);\n        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n        this.decrementCounts(previousSplit);\n        localStorage.setItem(splitKey, split);\n        var parsedSplit = split ? JSON.parse(split) : null;\n        this.incrementCounts(parsedSplit);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var _this = this;\n\n      var results = [];\n      entries.forEach(function (keyValuePair) {\n        results.push(_this.addSplit(keyValuePair[0], keyValuePair[1]));\n      });\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      try {\n        var split = this.getSplit(splitName);\n        localStorage.removeItem(this.keys.buildSplitKey(splitName));\n        var parsedSplit = JSON.parse(split);\n        this.decrementCounts(parsedSplit);\n        return 1;\n      } catch (e) {\n        log.error(e);\n        return 0;\n      }\n    }\n    /**\n     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.\n     */\n\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(names) {\n      var i = 0;\n      var len = names.length;\n      var counter = 0;\n\n      for (; i < len; i++) {\n        counter += this.removeSplit(names[i]);\n      }\n\n      return counter;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return localStorage.getItem(this.keys.buildSplitKey(splitName));\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      // when cache is ready but using a new split query, we must flush all split data\n      if (this.cacheReadyButNeedsToFlush) {\n        this.flush();\n        this.cacheReadyButNeedsToFlush = false;\n      } // when using a new split query, we must update it at the store\n\n\n      if (this.updateNewFilter) {\n        log.info('Split filter query was modified. Updating cache.');\n        var queryKey = this.keys.buildSplitsFilterQueryKey();\n        var queryString = this.splitFiltersValidation.queryString;\n\n        try {\n          if (queryString) localStorage.setItem(queryKey, queryString);else localStorage.removeItem(queryKey);\n        } catch (e) {\n          log.error(e);\n        }\n\n        this.updateNewFilter = false;\n      }\n\n      try {\n        localStorage.setItem(this.keys.buildSplitsTillKey(), changeNumber + ''); // update \"last updated\" timestamp with current time\n\n        localStorage.setItem(this.keys.buildLastUpdatedKey(), Date.now() + '');\n        this.hasSync = true;\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      var n = -1;\n      var value = localStorage.getItem(this.keys.buildSplitsTillKey());\n\n      if (value !== null) {\n        value = parseInt(value, 10);\n        return numberIsNaN(value) ? n : value;\n      }\n\n      return n;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        var value = key && localStorage.getItem(key);\n        if (key != null && this.keys.isSplitKey(key) && value) accum.push(value);\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        if (key != null && this.keys.isSplitKey(key)) accum.push(this.keys.extractKey(key));\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      var ttCount = toNumber(localStorage.getItem(this.keys.buildTrafficTypeKey(trafficType)));\n      return numberIsFinite(ttCount) && ttCount > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      // If cache hasn't been synchronized with the cloud, assume we need them.\n      if (!this.hasSync) return true;\n      var storedCount = localStorage.getItem(this.keys.buildSplitsWithSegmentCountKey());\n      var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n\n      if (numberIsFinite(splitsWithSegmentsCount)) {\n        return splitsWithSegmentsCount > 0;\n      } else {\n        return true;\n      }\n    }\n    /**\n     * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).\n     * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing Splits data from localStorage'); // collect item keys\n\n      var len = localStorage.length;\n      var accum = [];\n\n      for (var cur = 0; cur < len; cur++) {\n        var key = localStorage.key(cur);\n        if (key != null && this.keys.isSplitCacheKey(key)) accum.push(key);\n      } // remove items\n\n\n      accum.forEach(function (key) {\n        localStorage.removeItem(key);\n      });\n      this.hasSync = false;\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this2 = this;\n\n      var splits = {};\n      splitNames.forEach(function (splitName) {\n        splits[splitName] = localStorage.getItem(_this2.keys.buildSplitKey(splitName));\n      });\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache.\n     * It is used as condition to emit SDK_SPLITS_CACHE_LOADED, and then SDK_READY_FROM_CACHE.\n     * In this function we could add more code to check if the data is valid.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return this.getChangeNumber() > -1 || this.cacheReadyButNeedsToFlush;\n    }\n    /**\n     * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,\n     * Clean operation (flush) also updates `lastUpdated` timestamp with current time.\n     *\n     * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned\n     */\n\n  }, {\n    key: \"__checkExpiration\",\n    value: function __checkExpiration(expirationTimestamp) {\n      var value = localStorage.getItem(this.keys.buildLastUpdatedKey());\n\n      if (value !== null) {\n        value = parseInt(value, 10);\n        if (!numberIsNaN(value) && value < expirationTimestamp) this.flush();\n      }\n    }\n  }, {\n    key: \"__checkFilterQuery\",\n    value: function __checkFilterQuery() {\n      var _this3 = this;\n\n      var _this$splitFiltersVal = this.splitFiltersValidation,\n          queryString = _this$splitFiltersVal.queryString,\n          groupedFilters = _this$splitFiltersVal.groupedFilters;\n      var queryKey = this.keys.buildSplitsFilterQueryKey();\n      var currentQueryString = localStorage.getItem(queryKey);\n\n      if (currentQueryString !== queryString) {\n        try {\n          // mark cache to update the new query filter on first successful splits fetch\n          this.updateNewFilter = true; // if cache is ready:\n\n          if (this.checkCache()) {\n            // * set change number to -1, to fetch splits with -1 `since` value.\n            localStorage.setItem(this.keys.buildSplitsTillKey(), '-1'); // * remove from cache splits that doesn't match with the new filters\n\n            this.getKeys().forEach(function (splitName) {\n              if (queryString && (groupedFilters.byName.indexOf(splitName) > -1 || groupedFilters.byPrefix.some(function (prefix) {\n                return splitName.startsWith(prefix + '__');\n              }))) {\n                // * set `cacheReadyButNeedsToFlush` so that `checkCache` returns true (the storage is ready to be used) and the data is flushed before updating on first successful splits fetch\n                _this3.cacheReadyButNeedsToFlush = true;\n                return;\n              }\n\n              _this3.removeSplit(splitName);\n            });\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      } // if the filter didn't change, nothing is done\n\n    }\n  }]);\n\n  return SplitCacheLocalStorage;\n}();\n\nSplitCacheLocalStorage.prototype.killLocally = killLocally;\nexport default SplitCacheLocalStorage;","map":{"version":3,"sources":["/home/mandi/mandi/todolist/node_modules/@splitsoftware/splitio-react/es/splitio/storage/SplitCache/InLocalStorage.js"],"names":["_classCallCheck","_createClass","numberIsFinite","toNumber","numberIsNaN","usesSegments","logFactory","log","killLocally","SplitCacheLocalStorage","keys","expirationTimestamp","splitFiltersValidation","__checkExpiration","__checkFilterQuery","key","value","decrementCount","count","localStorage","getItem","setItem","removeItem","decrementCounts","split","trafficTypeName","ttKey","buildTrafficTypeKey","conditions","segmentsCountKey","buildSplitsWithSegmentCountKey","e","error","incrementCounts","addSplit","splitName","splitKey","buildSplitKey","splitFromLocalStorage","previousSplit","JSON","parse","parsedSplit","addSplits","entries","_this","results","forEach","keyValuePair","push","removeSplit","getSplit","removeSplits","names","i","len","length","counter","setChangeNumber","changeNumber","cacheReadyButNeedsToFlush","flush","updateNewFilter","info","queryKey","buildSplitsFilterQueryKey","queryString","buildSplitsTillKey","buildLastUpdatedKey","Date","now","hasSync","getChangeNumber","n","parseInt","getAll","accum","cur","isSplitKey","getKeys","extractKey","trafficTypeExists","trafficType","ttCount","storedCount","splitsWithSegmentsCount","isSplitCacheKey","fetchMany","splitNames","_this2","splits","checkCache","_this3","_this$splitFiltersVal","groupedFilters","currentQueryString","byName","indexOf","byPrefix","some","prefix","startsWith","prototype"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { numberIsFinite, toNumber, numberIsNaN } from '../../utils/lang';\nimport usesSegments from '../../utils/splits/usesSegments';\nimport logFactory from '../../utils/logger';\nvar log = logFactory('splitio-storage:localstorage');\nimport killLocally from './killLocally';\n\nvar SplitCacheLocalStorage = /*#__PURE__*/function () {\n  /**\n   * @param {Object} keys\n   * @param {number} expirationTimestamp\n   * @param {Object} splitFiltersValidation\n   */\n  function SplitCacheLocalStorage(keys, expirationTimestamp, splitFiltersValidation) {\n    _classCallCheck(this, SplitCacheLocalStorage);\n\n    this.keys = keys;\n    this.splitFiltersValidation = splitFiltersValidation;\n\n    this.__checkExpiration(expirationTimestamp);\n\n    this.__checkFilterQuery();\n  }\n\n  _createClass(SplitCacheLocalStorage, [{\n    key: \"decrementCount\",\n    value: function decrementCount(key) {\n      var count = toNumber(localStorage.getItem(key)) - 1;\n      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);\n    }\n  }, {\n    key: \"decrementCounts\",\n    value: function decrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            this.decrementCount(ttKey);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n            this.decrementCount(segmentsCountKey);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"incrementCounts\",\n    value: function incrementCounts(split) {\n      try {\n        if (split) {\n          if (split.trafficTypeName) {\n            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);\n            localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);\n          }\n\n          if (usesSegments(split.conditions)) {\n            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();\n            localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);\n          }\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n  }, {\n    key: \"addSplit\",\n    value: function addSplit(splitName, split) {\n      try {\n        var splitKey = this.keys.buildSplitKey(splitName);\n        var splitFromLocalStorage = localStorage.getItem(splitKey);\n        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;\n        this.decrementCounts(previousSplit);\n        localStorage.setItem(splitKey, split);\n        var parsedSplit = split ? JSON.parse(split) : null;\n        this.incrementCounts(parsedSplit);\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"addSplits\",\n    value: function addSplits(entries) {\n      var _this = this;\n\n      var results = [];\n      entries.forEach(function (keyValuePair) {\n        results.push(_this.addSplit(keyValuePair[0], keyValuePair[1]));\n      });\n      return results;\n    }\n  }, {\n    key: \"removeSplit\",\n    value: function removeSplit(splitName) {\n      try {\n        var split = this.getSplit(splitName);\n        localStorage.removeItem(this.keys.buildSplitKey(splitName));\n        var parsedSplit = JSON.parse(split);\n        this.decrementCounts(parsedSplit);\n        return 1;\n      } catch (e) {\n        log.error(e);\n        return 0;\n      }\n    }\n    /**\n     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.\n     */\n\n  }, {\n    key: \"removeSplits\",\n    value: function removeSplits(names) {\n      var i = 0;\n      var len = names.length;\n      var counter = 0;\n\n      for (; i < len; i++) {\n        counter += this.removeSplit(names[i]);\n      }\n\n      return counter;\n    }\n  }, {\n    key: \"getSplit\",\n    value: function getSplit(splitName) {\n      return localStorage.getItem(this.keys.buildSplitKey(splitName));\n    }\n  }, {\n    key: \"setChangeNumber\",\n    value: function setChangeNumber(changeNumber) {\n      // when cache is ready but using a new split query, we must flush all split data\n      if (this.cacheReadyButNeedsToFlush) {\n        this.flush();\n        this.cacheReadyButNeedsToFlush = false;\n      } // when using a new split query, we must update it at the store\n\n\n      if (this.updateNewFilter) {\n        log.info('Split filter query was modified. Updating cache.');\n        var queryKey = this.keys.buildSplitsFilterQueryKey();\n        var queryString = this.splitFiltersValidation.queryString;\n\n        try {\n          if (queryString) localStorage.setItem(queryKey, queryString);else localStorage.removeItem(queryKey);\n        } catch (e) {\n          log.error(e);\n        }\n\n        this.updateNewFilter = false;\n      }\n\n      try {\n        localStorage.setItem(this.keys.buildSplitsTillKey(), changeNumber + ''); // update \"last updated\" timestamp with current time\n\n        localStorage.setItem(this.keys.buildLastUpdatedKey(), Date.now() + '');\n        this.hasSync = true;\n        return true;\n      } catch (e) {\n        log.error(e);\n        return false;\n      }\n    }\n  }, {\n    key: \"getChangeNumber\",\n    value: function getChangeNumber() {\n      var n = -1;\n      var value = localStorage.getItem(this.keys.buildSplitsTillKey());\n\n      if (value !== null) {\n        value = parseInt(value, 10);\n        return numberIsNaN(value) ? n : value;\n      }\n\n      return n;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        var value = key && localStorage.getItem(key);\n        if (key != null && this.keys.isSplitKey(key) && value) accum.push(value);\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      var len = localStorage.length;\n      var accum = [];\n      var cur = 0;\n\n      while (cur < len) {\n        var key = localStorage.key(cur);\n        if (key != null && this.keys.isSplitKey(key)) accum.push(this.keys.extractKey(key));\n        cur++;\n      }\n\n      return accum;\n    }\n  }, {\n    key: \"trafficTypeExists\",\n    value: function trafficTypeExists(trafficType) {\n      var ttCount = toNumber(localStorage.getItem(this.keys.buildTrafficTypeKey(trafficType)));\n      return numberIsFinite(ttCount) && ttCount > 0;\n    }\n  }, {\n    key: \"usesSegments\",\n    value: function usesSegments() {\n      // If cache hasn't been synchronized with the cloud, assume we need them.\n      if (!this.hasSync) return true;\n      var storedCount = localStorage.getItem(this.keys.buildSplitsWithSegmentCountKey());\n      var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);\n\n      if (numberIsFinite(splitsWithSegmentsCount)) {\n        return splitsWithSegmentsCount > 0;\n      } else {\n        return true;\n      }\n    }\n    /**\n     * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).\n     * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      log.info('Flushing Splits data from localStorage'); // collect item keys\n\n      var len = localStorage.length;\n      var accum = [];\n\n      for (var cur = 0; cur < len; cur++) {\n        var key = localStorage.key(cur);\n        if (key != null && this.keys.isSplitCacheKey(key)) accum.push(key);\n      } // remove items\n\n\n      accum.forEach(function (key) {\n        localStorage.removeItem(key);\n      });\n      this.hasSync = false;\n    }\n    /**\n     * Fetches multiple splits definitions.\n     */\n\n  }, {\n    key: \"fetchMany\",\n    value: function fetchMany(splitNames) {\n      var _this2 = this;\n\n      var splits = {};\n      splitNames.forEach(function (splitName) {\n        splits[splitName] = localStorage.getItem(_this2.keys.buildSplitKey(splitName));\n      });\n      return splits;\n    }\n    /**\n     * Check if the splits information is already stored in cache.\n     * It is used as condition to emit SDK_SPLITS_CACHE_LOADED, and then SDK_READY_FROM_CACHE.\n     * In this function we could add more code to check if the data is valid.\n     */\n\n  }, {\n    key: \"checkCache\",\n    value: function checkCache() {\n      return this.getChangeNumber() > -1 || this.cacheReadyButNeedsToFlush;\n    }\n    /**\n     * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,\n     * Clean operation (flush) also updates `lastUpdated` timestamp with current time.\n     *\n     * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned\n     */\n\n  }, {\n    key: \"__checkExpiration\",\n    value: function __checkExpiration(expirationTimestamp) {\n      var value = localStorage.getItem(this.keys.buildLastUpdatedKey());\n\n      if (value !== null) {\n        value = parseInt(value, 10);\n        if (!numberIsNaN(value) && value < expirationTimestamp) this.flush();\n      }\n    }\n  }, {\n    key: \"__checkFilterQuery\",\n    value: function __checkFilterQuery() {\n      var _this3 = this;\n\n      var _this$splitFiltersVal = this.splitFiltersValidation,\n          queryString = _this$splitFiltersVal.queryString,\n          groupedFilters = _this$splitFiltersVal.groupedFilters;\n      var queryKey = this.keys.buildSplitsFilterQueryKey();\n      var currentQueryString = localStorage.getItem(queryKey);\n\n      if (currentQueryString !== queryString) {\n        try {\n          // mark cache to update the new query filter on first successful splits fetch\n          this.updateNewFilter = true; // if cache is ready:\n\n          if (this.checkCache()) {\n            // * set change number to -1, to fetch splits with -1 `since` value.\n            localStorage.setItem(this.keys.buildSplitsTillKey(), '-1'); // * remove from cache splits that doesn't match with the new filters\n\n            this.getKeys().forEach(function (splitName) {\n              if (queryString && (groupedFilters.byName.indexOf(splitName) > -1 || groupedFilters.byPrefix.some(function (prefix) {\n                return splitName.startsWith(prefix + '__');\n              }))) {\n                // * set `cacheReadyButNeedsToFlush` so that `checkCache` returns true (the storage is ready to be used) and the data is flushed before updating on first successful splits fetch\n                _this3.cacheReadyButNeedsToFlush = true;\n                return;\n              }\n\n              _this3.removeSplit(splitName);\n            });\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      } // if the filter didn't change, nothing is done\n\n    }\n  }]);\n\n  return SplitCacheLocalStorage;\n}();\n\nSplitCacheLocalStorage.prototype.killLocally = killLocally;\nexport default SplitCacheLocalStorage;"]},"metadata":{},"sourceType":"module"}